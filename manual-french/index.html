<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title>Le Manuel Neo4j v1.9-SNAPSHOT</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>

<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />
<link href="css/neo-asciidoc.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->

<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<!-- script type="text/javascript" src="js/sidebar.js"></script -->

<!-- Google Analytics -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1192232-16']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body class="book">
<div id="header">
<h1>Le Manuel Neo4j v1.9-SNAPSHOT</h1>
<div id="toc">
  <div id="toctitle">Table des matières</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction">Introduction</h2>
<div class="sectionbody">
<div class="openblock">
<div class="content">
<div class="paragraph"><p>Cette partie offre un aperçu de ce qu&#8217;est une base de données graphe et
souligne ensuite quelques spécificités de Neo4j.</p></div>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="introduction-highlights">Points forts de Neo4j</h2>
<div class="sectionbody">
<div class="paragraph"><p>Définie comme une base de données robuste, évolutive et très performante,
Neo4j convient aussi bien pour le deploiement en grande entreprise que pour
les projets plus légers en utilisant une partie du serveur complet.</p></div>
<div class="paragraph"><p>Fonctionnalités:</p></div>
<div class="ulist"><ul>
<li>
<p>
true ACID transactions,
</p>
</li>
<li>
<p>
high availability,
</p>
</li>
<li>
<p>
scales to billions of nodes and relationships,
</p>
</li>
<li>
<p>
high speed querying through traversals,
</p>
</li>
<li>
<p>
declarative graph query language.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Un comportement ACID sain est le fondement même de la fiabilité.  Neo4j
renforce cela en s&#8217;assurant que toutes les opérations modifiant les données
soient exécutées au sein d&#8217;une transaction, garantissant la cohérence des
données.  Cette robustesse s'étend depuis une simple instance de graphe
embarquée vers des installations multi-serveurs à haute disponibilité.  Pour
plus de détails, reportez-vous à <a href="#transactions">[transactions]</a>.</p></div>
<div class="paragraph"><p>Un système de stockage en graphe fiable peut facilement être ajouté à
n&#8217;importe quelle application.  Un graphe s'étend en taille et complexité au
fur et à mesure que l&#8217;application évolue, avec de faibles impacts sur la
performance.  Pour le commencement d&#8217;un nouveau projet comme pour l&#8217;ajout de
fonctionnalités existantes, Neo4j est adapté et n&#8217;est limité que par le
matériel physique.</p></div>
<div class="paragraph"><p>Une seule instance serveur peut traiter un graphe contenant des milliards de
noeuds et relations.  Quand le taux de transfert est insuffisant, la base de
données graphe peut être distribuée sur plusieurs serveurs dans une
configuration haute-disponibilité.  Lisez <a href="#ha">[ha]</a> pour en apprendre plus.</p></div>
<div class="paragraph"><p>Une base de données graphe brille quand elle stocke des données hautement
connectées.  Les requêtes sont exécutées à l&#8217;aide de traversées, qui peuvent
procéder à plusieurs millions de traversées par seconde.  Une traversée
ressemble à une <em>jointure</em> dans les bases de données relationnelles.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="graphdb-concepts">Concepts d&#8217;une base de données graphe</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ce chapitre contient une introduction au modèle de données en graphe et le
compare également à d&#8217;autres modèles de données utilisés pour la persistance
de données.</p></div>
<div class="sect2">
<h3 id="what-is-a-graphdb">Qu&#8217;est-ce qu&#8217;une base de données graphe?</h3>
<div class="paragraph"><p>Une base de données graphe stocke les données en graphe, structure de
données la plus générique, capable de représenter avec élégance n&#8217;importe
quel type de données d&#8217;une manière ultra accessible.  Laissons nous guider
le long de quelques graphes afin d&#8217;exprimer certains concepts.  Nous
"lirons" le graphe tout simplement en suivant ses flèches dans le diagramme
afin de former des phrases.</p></div>
<div class="sect3">
<h4 id="_un_graphe_contient_des_noeuds_et_des_relations">Un graphe contient des Noeuds et des Relations</h4>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>&#0171;Un graphe —enregistre les données en&#8594; Noeuds —qui contiennent des&#8594;
Propriétés&#0187;</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>The simplest possible graph is a single Node, a record that has named values
referred to as Properties.  A Node could start with a single Property and
grow to a few million Properties, though that can get a little awkward.  At
some point it makes sense to distribute the data into multiple nodes,
organized with explicit Relationships.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-GVE.svg" alt="graphdb-GVE.svg" />
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_relations_organisent_le_graphe">Les Relations organisent le graphe</h4>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>&#0171;Les Noeuds —sont organisés par des&#8594; Relations —qui contiennent également
des&#8594; Propriétés&#0187;</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Les Relations organisent les Noeuds en structures arbitraires, permettant à
un Graphe de ressembler à une Liste, une Hiérarchie, une Carte ou une Entité
composée&#8201;&#8212;&#8201;chacune de ces ressemblances pouvant être combinées en une
structure beaucoup plus complexe et richement connectée.</p></div>
</div>
<div class="sect3">
<h4 id="_interroger_un_graphe_à_l_8217_aide_d_8217_une_traversée">Interroger un Graphe à l&#8217;aide d&#8217;une Traversée</h4>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>&#0171;Une Traversée —navigue dans&#8594; un Graphe; elle —identifie des&#8594; Chemins
—qui ordonnent les&#8594; Noeuds&#0187;</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>uUne Traversée est la manière dont vous interrogez un Graphe, naviguant
depuis les Noeuds de départ vers les Noeuds reliés en accordance avec un
algorithme, répondant à des questions &#0171;Quelles chansons aiment mes amis
mais que je ne possède pas?&#0187; ou &#0171;si cette génératrice d'énergie tombe en
panne, quels services web sont affectés?&#0187;</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-traversal.svg" alt="graphdb-traversal.svg" />
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_indexs_indentifient_des_noeuds_ou_des_relations">Les indexs indentifient des Noeuds ou des Relations</h4>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>&#0171;Un Index —relie des&#8594; Properiétés —à des&#8594; Noeuds ou Relations&#0187;</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Parfois vous voulez trouver un Noeud ou une Relation spécifique en
accordance avec une Propriété qu&#8217;elle contient.  Plutôt que de traverser un
Graphe entier, utilisez un Index afin de procéder à une recherche comme
&#0171;trouver le Compte ayant comme nom d&#8217;utilisateur maître-des-graphes.&#0187;</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-indexes.svg" alt="graphdb-indexes.svg" />
</div>
</div>
</div>
<div class="sect3">
<h4 id="_neo4j_est_une_base_de_données_graphe">Neo4j est une base de données Graphe</h4>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>&#0171;Une base de données Graphe —gère un&#8594; Graphe et —gère aussi les&#8594; Indexs&#0187;</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Neo4j est une base de données graphe open-source supportée commercialement.
Elle a été conceptualisée et construite depuis le début afin d'être une base
de données fiable, optimisée pour les structures en graphe en place et lieu
de tables.  En travaillant avec Neo4j, votre application profite de toutes
les expressivités d&#8217;un graphe tout en vous garantissant la fiabilité que
vous attendez d&#8217;une base de données.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-overview.svg" alt="graphdb-overview.svg" />
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-comparing-models">Comparaison des modèles de données</h3>
<div class="paragraph"><p>Une base de données Graph stocke les données structurées dans les Noeuds et
Relatins d&#8217;un graphe.  Comment cela est-il comparé à d&#8217;autres modèles de
persistance? Du fait qu&#8217;un graphe est une structure générique, comparons ce
à quoi d&#8217;autres modèles auraient l&#8217;air dans un graphe.</p></div>
<div class="sect3">
<h4 id="_une_base_de_données_graphe_transforme_un_sgbdr">Une base de données graphe transforme un SGBDR</h4>
<div class="paragraph"><p>Renversez la pile d&#8217;enregistrements d&#8217;une base de données relationnelle et
vous verrez un graphe.  Là où un SGBDR est optimisé pour les données
aggrégées, Neo4j est optimisé pour les données fortement connectées.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-rdbms.svg" alt="graphdb-compare-rdbms.svg" />
</div>
<div class="title">Figure 1. SGBDR</div>
</div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-rdbms-g.svg" alt="graphdb-compare-rdbms-g.svg" />
</div>
<div class="title">Figure 2. Base de données Graphe comme SGBDR</div>
</div>
</div>
<div class="sect3">
<h4 id="_une_base_de_données_graphe_conçoit_les_stockages_clé_valeur">Une Base de données Graphe conçoit les Stockages Clé-Valeur</h4>
<div class="paragraph"><p>Un modèle Clé-Valeur est très bien pour la recherche de simples valeurs ou
de listes.  Quand ces valeurs sont elle-mêmes interconnectées, vous obtenez
un graphe.  Neo4j vous laisse concevoir une simple structure de données en
structure données interconnectées et plus complexes.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-kvstore.svg" alt="graphdb-compare-kvstore.svg" />
</div>
<div class="title">Figure 3. Key-Value Store</div>
</div>
<div class="paragraph"><p><code>K*</code> représente une clé, <code>V*</code> une valeur.  Notez que certaines clés pointent
vers d&#8217;autres clés comme vers des valeurs.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-kvstore-g.svg" alt="graphdb-compare-kvstore-g.svg" />
</div>
<div class="title">Figure 4. Graph Database as Key-Value Store</div>
</div>
</div>
<div class="sect3">
<h4 id="_une_base_de_données_graphe_conçoit_les_stockages_orientés_colonnes">Une Base de données Graphe conçoit les stockages Orientés Colonnes</h4>
<div class="paragraph"><p>La famille des stockages Orientés Colonnes (style BigTable) sont une
évolution du modèle Clé-Valeur, utilisant des "familles" afin de grouper
certaines lignes.  Enregistrées dans un graphe, ces familles peuvent devenir
hiérarchiques et les relations entre les données deviennent explicites.</p></div>
</div>
<div class="sect3">
<h4 id="_une_base_de_données_graphe_navigue_à_travers_un_stockage_orienté_documents">Une Base de données Graphe navigue à travers un stockage orienté Documents</h4>
<div class="paragraph"><p>L&#8217;hiérarchie en conteneur d&#8217;une base de données orientée document conçoit
facilement les données non schématisées qui peuvent être représentées en
Arbre, qui est évidemment un graphe.  Référez-vous à d&#8217;autres documents (ou
éléments de documents) au sein de ce même arbre et vous obtenez une
représentation plus expressive de ces mêmes données.  Dans Neo4j, ces
relations sont facilement naviguables.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-docdb.svg" alt="graphdb-compare-docdb.svg" />
</div>
<div class="title">Figure 5. Document Store</div>
</div>
<div class="paragraph"><p><code>D</code>=Document, <code>S</code>=Sousdocument, <code>V</code>=Valeur, <code>D2/S2</code> = Référence à un
Sousdocument dans un (autre) Document.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-compare-docdb-g.svg" alt="graphdb-compare-docdb-g.svg" />
</div>
<div class="title">Figure 6. Graph Database as Document Store</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="graphdb-neo4j">La base de données Graphe Neo4j</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ce chapître entre plus en détails dans le comportement et le modèle de
données de Neo4j.</p></div>
<div class="sect2">
<h3 id="graphdb-neo4j-nodes">Noeuds</h3>
<div class="paragraph"><p>Les unités fondamentales composant un graphe sont les noeuds et relations.
Dans Neo4j, aussi bien les noeuds que les relations peuvent contenir des
<a href="#graphdb-neo4j-properties">propriétés</a>.</p></div>
<div class="paragraph"><p>Les noeuds sont souvent utilisés pour représenter des <em>entités</em>, mais en
fonction de votre domaine des relations peuvent être utilisées pour cet
usage.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-nodes-overview.svg" alt="graphdb-nodes-overview.svg" />
</div>
</div>
<div class="paragraph"><p>Commençons avec un graphe super simple, contenant seulement un noeud avec
une propriété:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-nodes.svg" alt="graphdb-nodes.svg" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="graphdb-neo4j-relationships">Relations</h3>
<div class="paragraph"><p>Les relations entre les noeuds sont un élément clé d&#8217;une base de données
graphe.  Elles permettent de trouvent les données reliées.  Tout comme les
noeuds, les relations peuvent avoir des
<a href="#graphdb-neo4j-properties">propriétés</a>.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels-overview.svg" alt="graphdb-rels-overview.svg" />
</div>
</div>
<div class="paragraph"><p>Une relation connecte deux noeuds en guarantissant d&#8217;avoir des noeuds de
départ et d&#8217;arrivée valides.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels.svg" alt="graphdb-rels.svg" />
</div>
</div>
<div class="paragraph"><p>Du fait que les relations sont toujours directionnelles, elles peuvent être
visualisées comme entrantes ou sortantes d&#8217;un noeud, ce qui est utile quand
on traverse un graphe:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels-dir.svg" alt="graphdb-rels-dir.svg" />
</div>
</div>
<div class="paragraph"><p><em>Les relations sont traversées aussi efficacement dans n&#8217;importe quelle
direction.</em> Cela signifie qu&#8217;il est nullement nécessaire d&#8217;ajouter un
duplicata de la relation dans le sens opposé (en rapport avec les traversées
ou la performance).</p></div>
<div class="paragraph"><p>Bien que les relations ont toujours une direction, vous pouvez ignorer cette
direction quand cela n&#8217;est pas nécessaire dans votre application.</p></div>
<div class="paragraph"><p>Notez qu&#8217;un noeud peut également avoir des relations vers lui-même:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels-loop.svg" alt="graphdb-rels-loop.svg" />
</div>
</div>
<div class="paragraph"><p>Pour améliore encore plus la traversée d&#8217;un graphe, toutes les relations ont
un type de relation.  Notez que le terme <em>type</em> peut être ambigü ici, vous
pouvez plutôt penser à une <em>étiquette</em>.  Les exemples suivants montrent un
réseau social simple avec deux relations.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels-twitter.svg" alt="graphdb-rels-twitter.svg" />
</div>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tableau 1. Utilisation d&#8217;une direction et type de relation</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top"> Quoi </th>
<th align="left" valign="top"> Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">savoir qui une personne suit</p></td>
<td align="left" valign="top"><p class="table">relations <code>suit</code> sortantes, profondeur un</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">savoir les abonnés d&#8217;une personne</p></td>
<td align="left" valign="top"><p class="table">relations <code>suit</code> entrantes, profondeur un</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">savoir qui une personne bloque</p></td>
<td align="left" valign="top"><p class="table">relations <code>bloque</code> sortantes, profondeur un</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">savoir par qui une personne est bloquée</p></td>
<td align="left" valign="top"><p class="table">relations <code>bloque</code> entrantes, profondeur un</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Cet exemple est un modèle simple d&#8217;un système de fichiers, qui inclut des
liens symboliques:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-rels-filesys.svg" alt="graphdb-rels-filesys.svg" />
</div>
</div>
<div class="paragraph"><p>En fonction de ce que vous recherchez, vous utiliserez les directions et
types de relations pendant les traversées.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Quoi </th>
<th align="left" valign="top"> Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">chemin complet d&#8217;un fichier</p></td>
<td align="left" valign="top"><p class="table">relations <code>fichier</code> entrantes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tous les chemins d&#8217;un fichier</p></td>
<td align="left" valign="top"><p class="table">relations <code>fichier</code> et <code>lien symbolique</code> entrantes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tous les fichiers d&#8217;un dossier</p></td>
<td align="left" valign="top"><p class="table">relations <code>fichier</code> et <code>lien symbolique</code> sortantes, profondeur un</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tous les fichiers d&#8217;un dossier, sauf les liens symboliques</p></td>
<td align="left" valign="top"><p class="table">relations <code>fichier</code> sortantes, profondeur un</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tous les fichiers d&#8217;un dossier, récursivement</p></td>
<td align="left" valign="top"><p class="table">relations <code>fichier</code> et <code>lien symbolique</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="graphdb-neo4j-properties">Propriétés</h3>
<div class="paragraph"><p>Aussi bien les noeuds que les relations peuvent contenir des propriétés.</p></div>
<div class="paragraph"><p>Les propriétés sont des paires clé-valeur où les clés sont des chaînes des
caractères.  Les valeurs peuvent être aussi bien primitives ou un tableau de
types primitives.  Par exemple les valeurs <code>String</code>, <code>int</code> et <code>int[]</code> sont
des propriétés valides.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content"><code>null</code> n&#8217;est pas une valeur de propriété valide.  Null peut être modélisé
par l&#8217;absence d&#8217;une clé.</td>
</tr></table>
</div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-properties.svg" alt="graphdb-properties.svg" />
</div>
</div>
<div class="tableblock" id="property-value-types">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tableau 2. Type de valeurs de propriétés</caption>
<col width="15%" />
<col width="45%" />
<col width="40%" />
<thead>
<tr>
<th align="left" valign="top">Type </th>
<th align="left" valign="top"> Déscription </th>
<th align="left" valign="top"> rayon de valeurs</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>boolean</code></p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><code>true</code>/<code>false</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>byte</code></p></td>
<td align="left" valign="top"><p class="table">8-bit integer</p></td>
<td align="left" valign="top"><p class="table"><code>-128</code> to <code>127</code>, inclus</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>short</code></p></td>
<td align="left" valign="top"><p class="table">16-bit integer</p></td>
<td align="left" valign="top"><p class="table"><code>-32768</code> to <code>32767</code>, inclus</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>int</code></p></td>
<td align="left" valign="top"><p class="table">32-bit integer</p></td>
<td align="left" valign="top"><p class="table"><code>-2147483648</code> to <code>2147483647</code>, inclus</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>long</code></p></td>
<td align="left" valign="top"><p class="table">64-bit integer</p></td>
<td align="left" valign="top"><p class="table"><code>-9223372036854775808</code> to <code>9223372036854775807</code>, inclus</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>float</code></p></td>
<td align="left" valign="top"><p class="table">32-bit IEEE 754 nombre à virgule flottante</p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>double</code></p></td>
<td align="left" valign="top"><p class="table">64-bit IEEE 754 nombre à virgule flottante</p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>char</code></p></td>
<td align="left" valign="top"><p class="table">16-bit entiers non-signés représentant des caractères Unicode</p></td>
<td align="left" valign="top"><p class="table"><code>u0000</code> à <code>uffff</code> (<code>0</code> à <code>65535</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>String</code></p></td>
<td align="left" valign="top"><p class="table">séquence de caractères Unicode</p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Pour plus de détails sur les valeurs flottantes/doubles, voyez
<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.2.3">Java
Language Specification</a>.</p></div>
</div>
<div class="sect2">
<h3 id="graphdb-neo4j-paths">Chemins</h3>
<div class="paragraph"><p>Un chemin est un ou plusieurs noeuds avec des relations connectées,
généralement récupérés comme résultat d&#8217;une requête ou traversée.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-path.svg" alt="graphdb-path.svg" />
</div>
</div>
<div class="paragraph"><p>Le chemin le plus court possible a une longueur de zéro et ressemble à cela:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-path-example1.svg" alt="graphdb-path-example1.svg" />
</div>
</div>
<div class="paragraph"><p>Un chemin de longueur un:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-path-example2.svg" alt="graphdb-path-example2.svg" />
</div>
</div>
<div class="paragraph"><p>Another path of length one:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/graphdb-path-example-loop.svg" alt="graphdb-path-example-loop.svg" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="graphdb-neo4j-traversal">Traversées</h3>
<div class="paragraph"><p>Traverser un graphe signifie visiter ses noeuds et suivre ses relations,
cela en accordance avec certaines règles.  Dans la plupart des cas,
seulement un sous-graphe est visité du fait que vous connaissez déjà dans
quelle partie du graphe se trouvent les noeuds et relations qui vous
intéressent.</p></div>
<div class="paragraph"><p>Neo4j est fourni avec une API basée sur des callbacks, ce qui vous laisse la
possibilité de spécifier les règles pour les traversées.  A un niveau
basique, vous avez le choix entre les traversées &#0171;breadth&#0187; ou
&#0171;depth-first&#0187;.</p></div>
<div class="paragraph"><p>Pour une introduction plus en détails du framework de traversées, voyez le
<a href="#tutorial-traversal">[tutorial-traversal]</a>.  Pour des exemples de code Java, voyez
<a href="#tutorials-java-embedded-traversal">[tutorials-java-embedded-traversal]</a>.</p></div>
<div class="paragraph"><p>Les autres options pour traverser ou interroger un graphe dans Neo4j sont
<a href="#cypher-query-lang">Cypher</a> et <a href="#gremlin-plugin">Gremlin</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="operations">Opérations</h2>
<div class="sectionbody">
<div class="openblock">
<div class="content">
<div class="paragraph"><p>Cette partie décrit comment procéder à l&#8217;installation de Neo4j et la
maintenance de celle-ci.  Elle inclut des chapîtres comme la sauvegarde de
la base de données, le monitoring de sa santé ainsi que le diagnostic
d&#8217;erreurs.</p></div>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="deployment">Installation &amp; Déploiement</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="deployment-scenarios">Scénarios de déploiements</h3>
<div class="paragraph"><p>Neo4j peut être embarqué dans votre application (Embedded), être exécuté
comme serveur autonome (Neo4j Server) ou être déployé sur plusieurs machines
afin de fournir une haute disponibilité.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tableau 3. Neo4j deployment options</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">            </th>
<th align="left" valign="top"> Instance Unique       </th>
<th align="left" valign="top"> Instances Multiples</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table header">Embedded</p></td>
<td align="left" valign="top"><p class="table">EmbeddedGraphDatabase</p></td>
<td align="left" valign="top"><p class="table">HighlyAvailableGraphDatabase</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table header">Standalone</p></td>
<td align="left" valign="top"><p class="table">Neo4j Server</p></td>
<td align="left" valign="top"><p class="table">Neo4j Server high availability mode</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_serveur">Serveur</h4>
<div class="paragraph"><p>Neo4j est normalé accédé comme serveur autonome, soit directement via une
interface ReST ou via un pilote de langage spécifique.  Une information
détaillée sur le serveur Neo4j est disponible ici <a href="#server">[server]</a>.  Pour exécuter
le serveur et les systèmes embarqués en mode haute disponibilié, voyez
<a href="#ha">[ha]</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_embarquée_embedded">Embarquée (Embedded)</h4>
<div class="paragraph"><p>Neo4j peut être embarqué directement sur un serveur d&#8217;applications en
incluant les librairies Java appropriées.  Pendant le développement, vous
pouvez vous référer à l&#8217;API
<code><a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/graphdb/GraphDatabaseService.html">GraphDatabaseService</a></code>
.  Pour basculer d&#8217;une instance unique vers le mode instances multiples
haute disponibilité, il vous suffit simplement de basculer de la classe
concrète
<code><a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/kernel/EmbeddedGraphDatabase.html">EmbeddedGraphDatabase</a></code>
vers la
<code><a href="http://components.neo4j.org/neo4j-enterprise/1.9-SNAPSHOT/apidocs/org/neo4j/kernel/HighlyAvailableGraphDatabase.html">HighlyAvailableGraphDatabase</a></code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="deployment-requirements">Configuration système requise</h3>
<div class="paragraph"><p>La mémoire limite la taille du graphe, les I/O disques limitent les
performances lecture/écriture, comme toujours.</p></div>
<div class="sect3">
<h4 id="_processeur">Processeur</h4>
<div class="paragraph"><p>La performance est généralement liée à la mémoire ou aux I/O pour de larges
graphes, et calcule les limites du graphe qui pourraient être allouées en
mémoire.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Minimum
</dt>
<dd>
<p>
Intel 486
</p>
</dd>
<dt class="hdlist1">
Recommandé
</dt>
<dd>
<p>
Intel Core i7
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_mémoire">Mémoire</h4>
<div class="paragraph"><p>Plus de mémoire permet de plus grands graphes, mais induit le risque de
créer des opérations "Garbage Collection" assez larges.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Minimum
</dt>
<dd>
<p>
1GB
</p>
</dd>
<dt class="hdlist1">
Recommandé
</dt>
<dd>
<p>
4-8GB
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_disque">Disque</h4>
<div class="paragraph"><p>A côté de sa capacité, les caractéristiques de performances du disque sont
un élément majeur quant au choix du type de stockage.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Minimum
</dt>
<dd>
<p>
SCSI, EIDE
</p>
</dd>
<dt class="hdlist1">
Recommandé
</dt>
<dd>
<p>
SSD w/ SATA
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_système_de_fichiers">Système de fichiers</h4>
<div class="paragraph"><p>Pour un comportement ACID sain, le système de fichiers doit supporter
<em>flush</em> (fsync, fdatasync).</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Minimum
</dt>
<dd>
<p>
ext3 (ou similaire)
</p>
</dd>
<dt class="hdlist1">
Recommandé
</dt>
<dd>
<p>
ext4, ZFS
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_logiciel">Logiciel</h4>
<div class="paragraph"><p>Neo4j est basé sur Java.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Java
</dt>
<dd>
<p>
Oracle Java 6
</p>
</dd>
<dt class="hdlist1">
Système d&#8217;exploitation
</dt>
<dd>
<p>
Linux, Windows XP, Mac OS X
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_version_jdk">Version JDK</h4>
<div class="paragraph"><p>L&#8217;exécution de Neo4j est téstée continuellement avec</p></div>
<div class="ulist"><ul>
<li>
<p>
<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle
  Java Runtime Environment JRE 1.6</a>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="deployment-installation">Installation</h3>
<div class="paragraph"><p>Neo4j peut être installé comme serveur, s&#8217;exécutant aussi bien en <em>headless</em>
qu&#8217;en service système.  Pour les développeurs Java, il est également
possible d&#8217;utiliser Neo4j comme bibliothèque embarquée dans votre
application.</p></div>
<div class="paragraph"><p>Pour plus d&#8217;informations sur l&#8217;installation de Neo4j comme serveur,
référez-vous à <a href="#server-installation">[server-installation]</a>.</p></div>
<div class="paragraph"><p>Le tableau suivant énumère les éditions disponibles ainsi que leurs noms
pour l&#8217;utilisation de celles-ci par des outils de gestion de dépendances.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Suivez les liens dans le tableau pour plus de détails sur la configuration
des dépendances avec Maven, Apache Buildr, Apache Ivy et Groovy Grape!</td>
</tr></table>
</div>
<div class="tableblock" id="editions">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Tableau 4. Neo4j editions</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top">Edition     </th>
<th align="left" valign="top">Dépendance      </th>
<th align="left" valign="top">Déscription  </th>
<th align="left" valign="top">Licence</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Community</p></td>
<td align="left" valign="top"><p class="table"><a href="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j%22">org.neo4j:neo4j</a></p></td>
<td align="left" valign="top"><p class="table">une base de données graphe ultra performante, système transactionnel ACID complet</p></td>
<td align="left" valign="top"><p class="table">GPLv3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Advanced</p></td>
<td align="left" valign="top"><p class="table"><a href="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-advanced%22">org.neo4j:neo4j-advanced</a></p></td>
<td align="left" valign="top"><p class="table">ajouté d&#8217;un système de monitoring avancé</p></td>
<td align="left" valign="top"><p class="table">AGPLv3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Enterprise</p></td>
<td align="left" valign="top"><p class="table"><a href="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-enterprise%22">org.neo4j:neo4j-enterprise</a></p></td>
<td align="left" valign="top"><p class="table">ajouté d&#8217;un système de backup en ligne ainsi que de la haute disponibilité sur une grappe de serveurs (clustering)</p></td>
<td align="left" valign="top"><p class="table">AGPLv3</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Les dépendances listées ne contiennent pas l&#8217;implémentation, mais les ajoute
transitivement.</td>
</tr></table>
</div>
<div class="paragraph"><p>For more information regarding licensing, see the
<a href="http://www.neo4j.org/learn/licensing">Licensing Guide</a>.</p></div>
<div class="sect3">
<h4 id="_installation_embarquée_embedded">Installation Embarquée (Embedded)</h4>
<div class="paragraph"><p>La dernière version est toujours disponible depuis
<a href="http://neo4j.org/download">http://neo4j.org/download</a>, avec les autres distributions disponibles.  Après
avoir sélectionné quelle était la version appropriée pour votre plateforme,
embarquez Neo4j dans votre application en incluant le <em>jars</em> de la
bibliothèque Neo4j à votre build.  Vous pouvez soit copier les fichiers jar
du dossier <em>lib</em> du paquet téléchargé, ou alors utiliser directement les
artifacts disponibles depuis le Maven Central Repository
<span class="footnote"><br />[<a href="http://repo1.maven.org/maven2/org/neo4j/">http://repo1.maven.org/maven2/org/neo4j/</a>]<br /></span>. Les versions stables et
incrémentielles sont disponibles à cet endroit.</p></div>
<div class="listingblock">
<div class="title">Maven dependency</div>
<pre class="programlisting brush: xml">&lt;project&gt;
...
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j&lt;/artifactId&gt;
   &lt;version&gt;1.9-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
  ...
 &lt;/dependencies&gt;
...
&lt;/project&gt;</pre></div>
<div class="paragraph"><p><em>Where the <code>artifactId</code> is one of <code>neo4j</code>, <code>neo4j-advanced</code>,
<code>neo4j-enterprise</code>.</em></p></div>
</div>
<div class="sect3">
<h4 id="_installation_serveur">Installation Serveur</h4>
<div class="paragraph"><p>Veuillez vous référer à <a href="#serveur">[serveur]</a> et <a href="#server-installation">[server-installation]</a>.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorials">Tutorials</h2>
<div class="sectionbody">
<div class="openblock">
<div class="content">
<div class="paragraph"><p>Cette partie du tutoriel explique comme mettre en place votre environnement et écrire des programmes utilisant Neo4j.
Il vous guide du Hello World jusqu'à un usage avancé des graphes.</p></div>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="tutorials-java-embedded">Using Neo4j embedded in Java applications</h2>
<div class="sectionbody">
<div class="paragraph"><p>Embarquer Neo4j dans vos application Java est relativement simple.
Dans ce chapitre vous trouverez tout le nécessaire, depuis la mise en service de l&#8217;environnement jusqu'à une manipulation utile de vos données.</p></div>
<div class="sect2">
<h3 id="tutorials-java-embedded-setup">Inclure Neo4j dans vos projets</h3>
<div class="paragraph"><p>Après avoir sélectionné l'<a href="#editions">édition</a> appropriée pour votre plateforme, embarquez Neo4j dans votre application Java en incluant les jars de la libraire Neo4j dans votre build.
Les sections suivantes expliquent comment réaliser cela soit en modifiant directement les chemins de votre build soit en utilisant un gestionnaire de dépendances.</p></div>
<div class="sect3">
<h4 id="_ajoutez_neo4j_aux_chemins_de_votre_build">Ajoutez Neo4j aux chemins de votre build</h4>
<div class="paragraph"><p>Récupérez Neo4j depuis l&#8217;une des sources suivantes:</p></div>
<div class="ulist"><ul>
<li>
<p>
Décompressez l&#8217;archive (zip/tarball) Neo4j <a href="http://neo4j.org/download/">download</a> et utilisez les fiches <em>jar</em> se situant dans le dossier <em>lib/</em>.
</p>
</li>
<li>
<p>
Utilisez les fichiers <em>jar</em> disponibles depuis le <a href="http://search.maven.org/#search|ga|1|g%3A%22org.neo4j%22">Maven Central Repository</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ajoutez les fichiers jar à votre projet:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
JDK tools
</dt>
<dd>
<p>
 Ajoutez à <code>-classpath</code>
</p>
</dd>
<dt class="hdlist1">
Eclipse
</dt>
<dd>
<div class="ulist"><ul>
<li>
<p>
Cliquez droit sur le projet, ensuite choisissez <em>Build Path &#8594; Configure Build Path.</em>
   Dans la boîte de dialogue, choisissez <em>Add External JARs</em>, naviguez jusqu&#8217;au dossier <em>lib/</em> de Neo4j et sélectionnez tous les fichiers jar.
</p>
</li>
<li>
<p>
Une autre options est d&#8217;utiliser les <a href="http://help.eclipse.org/indigo/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/buildpath/ref-preferences-user-libraries.htm">Bibliothèques Utilisateur</a>.
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
IntelliJ IDEA
</dt>
<dd>
<p>
 Voyez <a href="http://www.jetbrains.com/idea/webhelp/libraries-global-libraries-and-the-configure-library-dialog.html">Bibliothèques, Bibliothèques globales et Configurer le dialogue Bibliothèque</a>
</p>
</dd>
<dt class="hdlist1">
NetBeans
</dt>
<dd>
<div class="ulist"><ul>
<li>
<p>
Cliquez droit sur le noeud <em>Bibliothèques</em> de votre projet, choisissez <em>Ajouter JAR/Dossier</em>, naviguez jusqu&#8217;au dossier <em>lib/</em> de Neo4j et sélectionnez tous les fichiers jar.
</p>
</li>
<li>
<p>
Vous pouvez également gérer les bibliothèques depuis le noeud du projet, voyez  <a href="http://netbeans.org/kb/docs/java/project-setup.html#projects-classpath">Gérer un Classpath projet</a>.
</p>
</li>
</ul></div>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="_ajoutez_neo4j_comme_dépendance">Ajoutez Neo4j comme dépendance</h4>
<div class="paragraph"><p>Pour une vue globale des principaux artifacts Neo4j, voyez <a href="#editions">[editions]</a>.
Les artifacts listés sont des artifacts de haut niveau qui inclueront transitivement l&#8217;implémentation Neo4j actuelle.
Vous pouvez utiliser directement l&#8217;artifact de haut niveau ou inclure directements les composants individuels.
Les exemples présentés utilisent l&#8217;approche d&#8217;inclusion de l&#8217;artifact de haut niveau.</p></div>
<div class="sect4">
<h5 id="_maven">Maven</h5>
<div class="listingblock">
<div class="title">Maven dependency</div>
<pre class="programlisting brush: xml">&lt;project&gt;
...
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j&lt;/artifactId&gt;
   &lt;version&gt;1.9-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
  ...
 &lt;/dependencies&gt;
...
&lt;/project&gt;</pre></div>
<div class="paragraph"><p><em>Où <code>artifactId</code> est trouvé dans <a href="#editions">[editions]</a>.</em></p></div>
</div>
<div class="sect4">
<h5 id="_eclipse_et_maven">Eclipse et Maven</h5>
<div class="paragraph"><p>Pour le développement dans <a href="http://www.eclipse.org">Eclipse</a>, il est recommandé d&#8217;installer le  <a href="http://www.eclipse.org/m2e/">plugin m2e</a> et de laisser Maven gérer le classpath du build du projet plutôt, voyez plus haut.
Ceci ajoute également la possibilité de construire votre projet par la ligne de commande avec Maven tout en ayant un environnement Eclipse fonctionnel pour le développement.</p></div>
</div>
<div class="sect4">
<h5 id="_ivy">Ivy</h5>
<div class="paragraph"><p>Assurez-vous de résoudre les dépendances depuis Maven Central, par exemple en utilisant cette configuration dans votre fichier <em>ivysettings.xml</em>:</p></div>
<div class="listingblock">
<div class="title">Ivy</div>
<pre class="programlisting brush: xml">---
&lt;ivysettings&gt;
  &lt;settings defaultResolver="main"/&gt;
  &lt;resolvers&gt;
    &lt;chain name="main"&gt;
      &lt;filesystem name="local"&gt;
        &lt;artifact pattern="${ivy.settings.dir}/repository/[artifact]-[revision].[ext]" /&gt;
      &lt;/filesystem&gt;
      &lt;ibiblio name="maven_central" root="http://repo1.maven.org/maven2/" m2compatible="true"/&gt;
    &lt;/chain&gt;
  &lt;/resolvers&gt;
&lt;/ivysettings&gt;
---</pre></div>
<div class="paragraph"><p>Avec ceci en place, vous pouvez ajouter Neo4j en ayant quelque chose de similaire à ces lignes dans votre fichier <em>ivy.xml</em>:</p></div>
<div class="listingblock">
<pre class="programlisting brush: xml">..
&lt;dependencies&gt;
  ..
  &lt;dependency org="org.neo4j" name="neo4j" rev="1.9-SNAPSHOT"/&gt;
  ..
&lt;/dependencies&gt;
..</pre></div>
<div class="paragraph"><p><em>Où <code>name</code> est trouvé dans <a href="#editions">[editions]</a>.</em></p></div>
</div>
<div class="sect4">
<h5 id="_gradle">Gradle</h5>
<div class="paragraph"><p>L&#8217;exemple ci-dessous montre un exemple d&#8217;un script de build gradle pour l&#8217;inclusion des bibliothèques Neo4j.</p></div>
<div class="listingblock">
<pre class="programlisting brush: groovy">def neo4jVersion = "1.9-SNAPSHOT"
apply plugin: 'java'
repositories {
   mavenCentral()
}
dependencies {
   compile "org.neo4j:neo4j:${neo4jVersion}"
}</pre></div>
<div class="paragraph"><p><em>Où les coordonnées (<code>org.neo4j:neo4j</code> in the example) sont trouvées dans <a href="#editions">[editions]</a>.</em></p></div>
</div>
</div>
<div class="sect3">
<h4 id="tutorials-java-embedded-setup-startstop">Démarrage et arrêt</h4>
<div class="paragraph"><p>Pour créer une nouvelle base de données ou ouvrir une existante, vous instantiez une <code><a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/kernel/EmbeddedGraphDatabase.html">EmbeddedGraphDatabase</a></code>.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
registerShutdownHook( graphDb );</pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">L&#8217;instance <code>EmbeddedGraphDatabase</code> peut être partagée à travers plusieurs processus.
Notez cependant que vous ne pouvez créer plusieurs instances pointant vers la même base de données.</td>
</tr></table>
</div>
<div class="paragraph"><p>Pour arrêter la base de données, appelez la méthode <code>shutdown()</code> :</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">graphDb.shutdown();</pre>
</div></div>
<div class="paragraph"><p>Afin de s&#8217;assurer que Neo4j est proprement arrêté, vous pouvez ajouter un hook d&#8217;arrêt:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static void registerShutdownHook( final GraphDatabaseService graphDb )
{
    // Registers a shutdown hook for the Neo4j instance so that it
    // shuts down nicely when the VM exits (even if you "Ctrl-C" the
    // running application).
    Runtime.getRuntime().addShutdownHook( new Thread()
    {
        @Override
        public void run()
        {
            graphDb.shutdown();
        }
    } );
}</pre>
</div></div>
<div class="paragraph"><p>Si vous désirez une <em>vue read-only</em> de la base de données, utilisez <code><a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/kernel/EmbeddedReadOnlyGraphDatabase.html">EmbeddedReadOnlyGraphDatabase</a></code>.</p></div>
<div class="paragraph"><p>Pour démarrer avec des paramètres de configurations, un ficher de paramètres Neo4j peut être chargé comme ceci:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Traceback (most recent call last):
  File "/var/lib/jenkins/.asciidoc/filters/snippet/snippet.py", line 88, in <module>
    for line in snippet(**configuration(indata)):
  File "/var/lib/jenkins/.asciidoc/filters/snippet/snippet.py", line 41, in snippet
    sourceFile = open(PATH_PATTERN % locals())
IOError: [Errno 2] No such file or directory: 'target/test-sources/neo4j-examples-test-sources-jar/org/neo4j/examples/StartWithConfiguration.java'</pre>
</div></div>
<div class="paragraph"><p>Ou vous pouvez bien évidemment créer votre propre  <code>Map&lt;String, String&gt;</code> automatiquement et utiliser celui-ci.</p></div>
<div class="paragraph"><p>Pour les options de configuration, voyez <a href="#embedded-configuration">[embedded-configuration]</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="tutorials-java-embedded-hello-world">Hello World</h3>
<div class="paragraph"><p>Apprenez comment créer et accéder aux noeuds et relations.
Pour des informations sur la mise en place d&#8217;un projet, référez-vous à <a href="#tutorials-java-embedded-setup">[tutorials-java-embedded-setup]</a>.</p></div>
<div class="paragraph"><p>Rappelez-vous, dans <a href="#what-is-a-graphdb">Qu&#8217;est-ce qu&#8217;une base de données graphe</a>, qu&#8217;un graphe Neo4j consiste en:</p></div>
<div class="ulist"><ul>
<li>
<p>
des Noeuds connectés par
</p>
</li>
<li>
<p>
des Relations avec
</p>
</li>
<li>
<p>
des Propriétés aussi bien pour les Noeuds que pour les Relations
</p>
</li>
</ul></div>
<div class="paragraph"><p>Toutes les relations ont un type.
Par exemple, si le graphe représente un réseau social, une relation pourrait être du type <code>CONNAIT</code>.
Si une relation du type <code>CONNAIT</code> relie deux noeuds, cela représente probablement deux personnes qui se connaissent.
Une grande partie de la sémantique (qui en est la définition) d&#8217;un graphe est encodée dans les types de relations de l&#8217;application.
Et même si les relations sont orientées, elles sont traversées aussi efficacement dans n&#8217;importe laquelle des deux directions.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Le code source de cet exemple peut être trouvé ici:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4j.java">EmbeddedNeo4j.java</a></td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_préparation_de_la_base_de_données">Préparation de la base de données</h4>
<div class="paragraph"><p>Les types de relations peuvent être créés en utilisant un <code>enum</code>.
Dans cet exemple nous aurons besoin d&#8217;un seul type de relation simple. Voici comment le définir:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static enum RelTypes implements RelationshipType
{
    KNOWS
}</pre>
</div></div>
<div class="paragraph"><p>Nous préparons également quelques variables à utiliser:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">GraphDatabaseService graphDb;
Node firstNode;
Node secondNode;
Relationship relationship;</pre>
</div></div>
<div class="paragraph"><p>La prochaine étape consiste à démarrer le serveur de la base de données.
Notez que si le répertoire spécifié pour la base de données n&#8217;existe pas encore, il sera créé.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
registerShutdownHook( graphDb );</pre>
</div></div>
<div class="paragraph"><p>Notez que démarrer le serveur de la base de données est une opération relativement coûteuse, donc ne démarrez pas une nouvelle instance à chaque fois que vous devez interagir avec la base de données!
L&#8217;instance peut être partagée entre plusieurs processus.
Les transactions sont confinées dans leur processus.</p></div>
<div class="paragraph"><p>Comme vu précédemment, nous enregistrons un hook d&#8217;arrêt qui s&#8217;assurera que la base de données s&#8217;arrête à la sortie du JVM.
Maintenant il est temps d&#8217;interagir avec la base de données.</p></div>
</div>
<div class="sect3">
<h4 id="_confinez_vos_écritures_dans_une_transaction">Confinez vos écritures dans une transaction</h4>
<div class="paragraph"><p>Toutes les écritures (création, suppression et mise à jour de données) doivent être exéctutées dans une transaction.
Ceci est une décision de design réfléchie, nous pensons vraiment que la démarquation des transactions est une partie importante quand on travaille avec une base de données vraiment orientée entreprises.
Maintenant, la manipulation des transactions avec Neo4j est très simple:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Transaction tx = graphDb.beginTx();
try
{
    // Updating operations go here
    tx.success();
}
finally
{
    tx.finish();
}</pre>
</div></div>
<div class="paragraph"><p>Pour plus d&#8217;informations sur les transactions, voyez <a href="#transactions">[transactions]</a> et
<a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/graphdb/Transaction.html">Java API for Transaction</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_création_d_8217_un_petit_graphe">Création d&#8217;un petit graphe</h4>
<div class="paragraph"><p>Maintenant, créons quelques noeuds.
L&#8217;API est très intuitive.
N&#8217;hésitez pas à jeter un oeil aux Javadocs à <a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/">http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/</a>.
Elles sont également inclues dans la distribution.
Voici comment créer un petit graphe constituant de deux noeuds, connectés entre eux par une relation et quelques propriétes:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">firstNode = graphDb.createNode();
firstNode.setProperty( "message", "Hello, " );
secondNode = graphDb.createNode();
secondNode.setProperty( "message", "World!" );

relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );
relationship.setProperty( "message", "brave Neo4j " );</pre>
</div></div>
<div class="paragraph"><p>Nous avons maintenant un graphe qui ressemble à cela :</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/Hello-World-Graph-java.svg" alt="Hello-World-Graph-java.svg" />
</div>
<div class="title">Figure 7. Hello World Graph</div>
</div>
</div>
<div class="sect3">
<h4 id="_affichage_du_résultat">Affichage du résultat</h4>
<div class="paragraph"><p>Après avoir créé notre graphe, voyons comme le lire et l&#8217;afficher.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">System.out.print( firstNode.getProperty( "message" ) );
System.out.print( relationship.getProperty( "message" ) );
System.out.print( secondNode.getProperty( "message" ) );</pre>
</div></div>
<div class="paragraph"><p>Ce qui affichera:</p></div>
<div class="paragraph"><p>Hello, brave Neo4j World!</p></div>
</div>
<div class="sect3">
<h4 id="_suppression_de_données">Suppression de données</h4>
<div class="paragraph"><p>Dans ce cas, nous supprimons les données avant le commit:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">// let's remove the data
firstNode.getSingleRelationship( RelTypes.KNOWS, Direction.OUTGOING ).delete();
firstNode.delete();
secondNode.delete();</pre>
</div></div>
<div class="paragraph"><p>Notez que supprimer un noeud qui contient toujours des relations au commit de la transaction résultera en un échec.
Ceci est pour s&#8217;assurer que les relations aient toujours un noeud de départ de d&#8217;arrivée.</p></div>
</div>
<div class="sect3">
<h4 id="_arrêt_du_serveur_de_la_base_de_données">Arrêt du serveur de la base de données</h4>
<div class="paragraph"><p>Enfin, arrêtez le serveur de la base de données <em>quand l&#8217;application se termine:</em></p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">graphDb.shutdown();</pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="tutorials-java-embedded-index">Base de données d&#8217;utilisateurs avec index</h3>
<div class="paragraph"><p>Vous avez une base de données d&#8217;utilisateurs et vous voulez retrouver les utilisateurs par nom.
Pour commencer, voici la structure de la base de données que nous voulons créer:</p></div>
<div class="imageblock">
<div class="content">
<img src="images/users.png" alt="users.png" />
</div>
<div class="title">Figure 8. Node space view of users</div>
</div>
<div class="paragraph"><p>Donc, le noeud de référence est connecté à une référence de noeuds d&#8217;utilisateurs à qui sont connectés tous les noeuds utilisateurs.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Le code source de cet exemple peut être trouvé ici:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4jWithIndexing.java">EmbeddedNeo4jWithIndexing.java</a></td>
</tr></table>
</div>
<div class="paragraph"><p>Pour commencer, nous définissons les types de relations que nous voulons utiliser:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Traceback (most recent call last):
  File "/var/lib/jenkins/.asciidoc/filters/snippet/snippet.py", line 88, in <module>
    for line in snippet(**configuration(indata)):
  File "/var/lib/jenkins/.asciidoc/filters/snippet/snippet.py", line 67, in snippet
    raise ValueError('Missing snippet for tag "' + tag + '" in file "' + source + '" in component "' + component +'" with classifier "' + classifier + '".')
ValueError: Missing snippet for tag "createRelTypes" in file "org/neo4j/examples/EmbeddedNeo4jWithIndexing.java" in component "neo4j-examples" with classifier "sources".</pre>
</div></div>
<div class="paragraph"><p>Ensuite nous créeons deux méthodes d&#8217;aider pour gérer les noms d&#8217;utilisateurs et ajouter les utilisateurs à la base de données:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static String idToUserName( final int id )
{
    return "user" + id + "@neo4j.org";
}

private static Node createAndIndexUser( final String username )
{
    Node node = graphDb.createNode();
    node.setProperty( USERNAME_KEY, username );
    nodeIndex.add( node, USERNAME_KEY, username );
    return node;
}</pre>
</div></div>
<div class="paragraph"><p>La prochaine étape consiste à démarrer le serveur de la base de données:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
nodeIndex = graphDb.index().forNodes( "nodes" );
registerShutdownHook();</pre>
</div></div>
<div class="paragraph"><p>Il est temps d&#8217;ajouter les utilisateurs:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Transaction tx = graphDb.beginTx();
try
{
    // Create some users and index their names with the IndexService
    for ( int id = 0; id < 100; id++ )
    {
        Node userNode = createAndIndexUser( idToUserName( id ) );
    }</pre>
</div></div>
<div class="paragraph"><p>Et voici comment retrouver un utilisateur par son Id:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">int idToFind = 45;
String userName = idToUserName( idToFind );
Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();
System.out.println( "The username of user " + idToFind + " is "
    + foundUser.getProperty( USERNAME_KEY ) );</pre>
</div></div>
</div>
<div class="sect2">
<h3 id="tutorials-java-unit-testing">Tests unitaires de base</h3>
<div class="paragraph"><p>Le modèle basique de test unitaire avec Neo4j est illustré par l&#8217;exemple suivant.</p></div>
<div class="paragraph"><p>Afin d&#8217;accéder aux facilités de tests Neo4j vous devez avoir le <code>neo4j-kernel</code> <em>tests.jar</em> au classpath pendant les tests.
Vous pouvez le télécharger depuis le Maven Central: <a href="http://search.maven.org/#search|ga|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22">org.neo4j:neo4j-kernel</a>.</p></div>
<div class="paragraph"><p>En utilisant Maven comme gestionnaire de dépendances, vous ajouteriez cette dépendance comme ceci:</p></div>
<div class="paragraph"><p>To access the Neo4j testing facilities you should have the <code>neo4j-kernel</code> <em>tests.jar</em> on the classpath during tests.
You can download it from Maven Central: <a href="http://search.maven.org/#search|ga|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22">org.neo4j:neo4j-kernel</a>.</p></div>
<div class="listingblock">
<div class="title">Maven dependency</div>
<pre class="programlisting brush: xml">&lt;project&gt;
...
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j-kernel&lt;/artifactId&gt;
   &lt;version&gt;${neo4j-version}&lt;/version&gt;
   &lt;type&gt;test-jar&lt;/type&gt;
   &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  ...
 &lt;/dependencies&gt;
...
&lt;/project&gt;</pre></div>
<div class="paragraph"><p><em>Où <code>${neo4j-version}</code> est la version désirée de Neo4j.</em></p></div>
<div class="paragraph"><p>Avec ceci en place, nous sommes prêts à coder nos tests.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Pour le code complet de cet exemple, voyez:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/test/java/org/neo4j/examples/Neo4jBasicTest.java">Neo4jBasicTest.java</a></td>
</tr></table>
</div>
<div class="paragraph"><p>Avant chaque test, créez une base de données saine:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">@Before
public void prepareTestDatabase()
{
    graphDb = new TestGraphDatabaseFactory().newImpermanentDatabase();
}</pre>
</div></div>
<div class="paragraph"><p>Après que les tests aient été exécutés, la base de données doit être arrêtée:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">@After
public void destroyTestDatabase()
{
    graphDb.shutdown();
}</pre>
</div></div>
<div class="paragraph"><p>Pendant un test, créez des noeuds et vérifiez qu&#8217;ils sont bien présents en accolant vos opérations d'écriture dans une transaction.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Transaction tx = graphDb.beginTx();

Node n = null;
try
{
    n = graphDb.createNode();
    n.setProperty( "name", "Nancy" );
    tx.success();
}
catch ( Exception e )
{
    tx.failure();
}
finally
{
    tx.finish();
}

// The node should have an id greater than 0, which is the id of the
// reference node.
assertThat( n.getId(), is( greaterThan( 0l ) ) );

// Retrieve a node by using the id of the created node. The id's and
// property should match.
Node foundNode = graphDb.getNodeById( n.getId() );
assertThat( foundNode.getId(), is( n.getId() ) );
assertThat( (String) foundNode.getProperty( "name" ), is( "Nancy" ) );</pre>
</div></div>
<div class="paragraph"><p>Si vous désirez spécifier des options de configuration pendant la création de la base de données, c&#8217;est réalise comme cela:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, String> config = new HashMap<String, String>();
config.put( "neostore.nodestore.db.mapped_memory", "10M" );
config.put( "string_block_size", "60" );
config.put( "array_block_size", "300" );
GraphDatabaseService db = new TestGraphDatabaseFactory()
    .newImpermanentDatabaseBuilder()
    .setConfig( config )
    .newGraphDatabase();</pre>
</div></div>
</div>
<div class="sect2">
<h3 id="tutorials-java-embedded-traversal">Traversier</h3>
<div class="paragraph"><p>Pour des informations sur le traversier, voyez <a href="#tutorial-traversal">[tutorial-traversal]</a>.</p></div>
<div class="paragraph"><p>Pour plus d&#8217;exemples sur le traversier, voyez <a href="#data-modeling-examples">[data-modeling-examples]</a>.</p></div>
<div class="sect3">
<h4 id="_la_matrice">La Matrice</h4>
<div class="paragraph"><p>Les parcours (traversées) des exemples de Matrice ci-dessus, cette fois en utilisant la nouvelle API du Traversier:</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Le code source des exemples peut être trouvé ici:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/NewMatrix.java">NewMatrix.java</a></td>
</tr></table>
</div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static Traverser getFriends(
        final Node person )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator( Evaluators.excludeStartPosition() );
    return td.traverse( person );
}</pre>
</div></div>
<div class="paragraph"><p>Exécutons ce parcours et affichons le résultat:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">int numberOfFriends = 0;
String output = neoNode.getProperty( "name" ) + "'s friends:\n";
Traverser friendsTraverser = getFriends( neoNode );
for ( Path friendPath : friendsTraverser )
{
    output += "At depth " + friendPath.length() + " => "
              + friendPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfFriends++;
}
output += "Number of friends found: " + numberOfFriends + "\n";</pre>
</div></div>
<div class="paragraph"><p>Ce qui nous donnera la sortie suivante:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
Number of friends found: 4</pre></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static Traverser findHackers( final Node startNode )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.CODED_BY, Direction.OUTGOING )
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator(
                    Evaluators.includeWhereLastRelationshipTypeIs( RelTypes.CODED_BY ) );
    return td.traverse( startNode );
}</pre>
</div></div>
<div class="paragraph"><p>Affichage du résultat:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">String output = "Hackers:\n";
int numberOfHackers = 0;
Traverser traverser = findHackers( getNeoNode() );
for ( Path hackerPath : traverser )
{
    output += "At depth " + hackerPath.length() + " => "
              + hackerPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfHackers++;
}
output += "Number of hackers found: " + numberOfHackers + "\n";</pre>
</div></div>
<div class="paragraph"><p>Maintenant nous savons qui a codé la Matrice:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">Hackers:
At depth 4 =&gt; The Architect
Number of hackers found: 1</pre></div>
<div class="sect4">
<h5 id="_parcours_d_8217_un_chemin_orienté">Parcours d&#8217;un chemin orienté</h5>
<div class="paragraph"><p>Cet exemple montre comment utiliser un contexte de chemin contenant une représentation de celui-ci.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Le code source de cet exemple peut-être trouvé ici:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/orderedpath/OrderedPath.java">OrderedPath.java</a></td>
</tr></table>
</div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Node A = db.createNode();
Node B = db.createNode();
Node C = db.createNode();
Node D = db.createNode();
A.createRelationshipTo( B, REL1 );
B.createRelationshipTo( C, REL2 );
C.createRelationshipTo( D, REL3 );
A.createRelationshipTo( C, REL2 );</pre>
</div></div>
<div class="imageblock dot">
<div class="content">
<img src="images/example-ordered-path.svg" alt="example-ordered-path.svg" />
</div>
</div>
<div class="paragraph"><p>Maintenant, l&#8217;ordre des relations (<code>REL1</code> &#8594; <code>REL2</code> &#8594; <code>REL3</code>) est enregistré dans <code>ArrayList</code>.
Au parcours, l' <code>Evaluator</code> peut l&#8217;utiliser comme moyen de vérification afin de s&#8217;assurer que seuls les chemins ayant cet ordre prédéfini de relations seront inclus et retournés:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">final ArrayList<RelationshipType> orderedPathContext = new ArrayList<RelationshipType>();
orderedPathContext.add( REL1 );
orderedPathContext.add( withName( "REL2" ) );
orderedPathContext.add( withName( "REL3" ) );
TraversalDescription td = Traversal.description()
        .evaluator( new Evaluator()
        {
            @Override
            public Evaluation evaluate( final Path path )
            {
                if ( path.length() == 0 )
                {
                    return Evaluation.EXCLUDE_AND_CONTINUE;
                }
                RelationshipType expectedType = orderedPathContext.get( path.length() - 1 );
                boolean isExpectedType = path.lastRelationship()
                        .isType( expectedType );
                boolean included = path.length() == orderedPathContext.size()
                                   && isExpectedType;
                boolean continued = path.length() < orderedPathContext.size()
                                    && isExpectedType;
                return Evaluation.of( included, continued );
            }
        } );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Traverser traverser = td.traverse( A );
PathPrinter pathPrinter = new PathPrinter( "name" );
for ( Path path : traverser )
{
    output += Traversal.pathToString( path, pathPrinter );
}</pre>
</div></div>
<div class="paragraph"><p>Ce qui affichera:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">(A)--[REL1]--&gt;(B)--[REL2]--&gt;(C)--[REL3]--&gt;(D)</pre></div>
<div class="paragraph"><p>Nous utilisons ici une classe personalisée afin de formatter la sortie du chemin.
C&#8217;est réalisé comme cela:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">static class PathPrinter implements Traversal.PathDescriptor<Path>
{
    private final String nodePropertyKey;

    public PathPrinter( String nodePropertyKey )
    {
        this.nodePropertyKey = nodePropertyKey;
    }

    @Override
    public String nodeRepresentation( Path path, Node node )
    {
        return "(" + node.getProperty( nodePropertyKey, "" ) + ")";
    }

    @Override
    public String relationshipRepresentation( Path path, Node from,
            Relationship relationship )
    {
        String prefix = "--", suffix = "--";
        if ( from.equals( relationship.getEndNode() ) )
        {
            prefix = "<--";
        }
        else
        {
            suffix = "-->";
        }
        return prefix + "[" + relationship.getType().name() + "]" + suffix;
    }
}</pre>
</div></div>
<div class="paragraph"><p>Pour des options en rapport avec la sortie d&#8217;un <code>Chemin</code>, reportez-vous à la classe
<a href="http://components.neo4j.org/neo4j/1.9-SNAPSHOT/apidocs/org/neo4j/kernel/Traversal.html">Traversal</a>.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Les exemples suivants utilisent une version dépréciée de l&#8217;API du Traversier.
Ils partagent l&#8217;implémentation en bas niveau de la nouvelle API du Traversier, ainsi ils sont égals au niveau performance.
Les fonctionnalités qu&#8217;elle propose sont cependant limitées comparativement.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ancienne_api_du_traversier">Ancienne API du Traversier</h4>
<div class="paragraph"><p>C&#8217;est ici le premier graphe dans lequel nous voulons parcourir:</p></div>
<div class="imageblock">
<div class="content">
<img src="images/examples-matrix.png" alt="examples-matrix.png" />
</div>
<div class="title">Figure 9. Matrix node space view</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Le code source de cet exemple peut être trouvé ici:
<a href="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/Matrix.java">Matrix.java</a></td>
</tr></table>
</div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static Traverser getFriends( final Node person )
{
    return person.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH,
            ReturnableEvaluator.ALL_BUT_START_NODE, RelTypes.KNOWS,
            Direction.OUTGOING );
}</pre>
</div></div>
<div class="paragraph"><p>Exécutons un parcours et affichons le résultat:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">int numberOfFriends = 0;
String output = neoNode.getProperty( "name" ) + "'s friends:\n";
Traverser friendsTraverser = getFriends( neoNode );
for ( Node friendNode : friendsTraverser )
{
    output += "At depth " +
                friendsTraverser.currentPosition().depth() +
                " => " +
                friendNode.getProperty( "name" ) + "\n";
    numberOfFriends++;
}
output += "Number of friends found: " + numberOfFriends + "\n";</pre>
</div></div>
<div class="paragraph"><p>Ce qui donnera l&#8217;affichage suivant:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
Number of friends found: 4</pre></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">private static Traverser findHackers( final Node startNode )
{
    return startNode.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH, new ReturnableEvaluator()
    {
        @Override
        public boolean isReturnableNode(
                final TraversalPosition currentPos )
        {
            return !currentPos.isStartNode()
            && currentPos.lastRelationshipTraversed()
            .isType( RelTypes.CODED_BY );
        }
    }, RelTypes.CODED_BY, Direction.OUTGOING, RelTypes.KNOWS,
    Direction.OUTGOING );
}</pre>
</div></div>
<div class="paragraph"><p>Affichons le résultat:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">String output = "Hackers:\n";
int numberOfHackers = 0;
Traverser traverser = findHackers( getNeoNode() );
for ( Node hackerNode : traverser )
{
    output += "At depth " +
                traverser.currentPosition().depth() +
                " => " +
                hackerNode.getProperty( "name" ) + "\n";
    numberOfHackers++;
}
output += "Number of hackers found: " + numberOfHackers + "\n";</pre>
</div></div>
<div class="paragraph"><p>Nous savons maintenant qui a codé la Matrice:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">Hackers:
At depth 4 =&gt; The Architect
Number of hackers found: 1</pre></div>
</div>
<div class="sect3">
<h4 id="examples-uniqueness-of-paths-in-traversals">Unicité des chemins dans les parcours de graphe</h4>
<div class="paragraph"><p>Cet exemple démontre l&#8217;utilisation de noeuds uniques.
Partons d&#8217;un graphe imaginaire de Particuliers qui détentent des Animaux qui eux-mêmes sont descendants d&#8217;autres Animaux.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Le nom des variables dans les exemples sont en Anglais, le code des exemples provient de tests unitaires et est donc tout le temps à jour.</td>
</tr></table>
</div>
<div class="imageblock dot">
<div class="content">
<img src="images/Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg" alt="Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg" />
</div>
<div class="title">Figure 10. Exemple de Graphe de Descendants</div>
</div>
<div class="paragraph"><p>Afin de retourner tous les descendants de <code>Pet0</code> qui a une relation <code>owns</code> avec <code>Principal1</code> (<code>Pet1</code> et <code>Pet3</code>), l&#8217;Unicité du parcours a besoin d'être défini à <code>NODE_PATH</code> plutôt qu'à <code>NODE_GLOBAL</code> ansi les noeuds peuvent être traversés plus d&#8217;une fois et les chemins qui ont des noeuds différents et aussi communs (comme le noeud de départ et d&#8217;arrivée) peuvent etre retournés.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">final Node target = data.get().get( "Principal1" );
TraversalDescription td = Traversal.description()
        .uniqueness( Uniqueness.NODE_PATH )
        .evaluator( new Evaluator()
{
    @Override
    public Evaluation evaluate( Path path )
    {
        if ( path.endNode().equals( target ) )
        {
            return Evaluation.INCLUDE_AND_PRUNE;
        }
        return Evaluation.EXCLUDE_AND_CONTINUE;
    }
} );

Traverser results = td.traverse( start );</pre>
</div></div>
<div class="paragraph"><p>Ceci retournera les chemins suivants:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">(3)--[descendant,0]--&gt;(1)&lt;--[owns,3]--(5)
(3)--[descendant,2]--&gt;(4)&lt;--[owns,5]--(5)</pre></div>
<div class="paragraph"><p>Dans l&#8217;implémentation par défaut <code>path.toString()</code>, <code>(1)--[knows,2]--&gt;(4)</code> dénote un noeuds avec un ID=1 ayant une relation avec pour ID=2 ou un type=KNOWS vers un noeud qui a pour ID=4.</p></div>
<div class="paragraph"><p>Créons maintenant une nouvelle <code>Déscription de Parcous</code> en rapport avec l&#8217;ancien, ayant une unicité sur <code>NODE_GLOBAL</code> pour voir la différence.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">L&#8217;objet <code>TraversalDescription</code> est immuable,
     nous devons donc utiliser la nouvelle instance retournée
     avec le nouveau paramètre d&#8217;unicité.</td>
</tr></table>
</div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">TraversalDescription nodeGlobalTd = td.uniqueness( Uniqueness.NODE_GLOBAL );
results = nodeGlobalTd.traverse( start );</pre>
</div></div>
<div class="paragraph"><p>Maintenant, un seul chemin est retourné:</p></div>
<div class="listingblock">
<pre class="programlisting brush: plain">(3)--[descendant,0]--&gt;(1)&lt;--[owns,3]--(5)</pre></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-query-lang">Cypher Query Language</h2>
<div class="sectionbody">
<div class="paragraph"><p>Cypher est un langage de requêtage déclaratif. Il permet d&#8217;effectuer des
requêtes et mises  jour du graphe efficaces sans avoir  écrire de
traversiers. Cypher is encore en phase d'évolution et de maturation, ce qui
signifie qu&#8217;il y aura certainement des changes de syntaxe qui ne seront pas
rétro compatibles. Cela signifie aussi que Cypher n&#8217;a pas encore t soumis
aux tests de performance rigoureux comme les autres composants Neo4j.</p></div>
<div class="paragraph"><p>Cypher est destiné à être un langage de requêtage humain, approprié aussi
bien aux développeurs qu&#8217;aux ( et cela nous semble important ) testeurs qui
veulent faire des requêtes ad-hoc sur la base de données. Notre ligne de
conduite est de rendre simple les choses simples et possible les choses
complexes. Sa construction est basée sur la prose Anglaise et une
iconographie innée, ce qui aide à rendre ce langage auto-descriptif.</p></div>
<div class="paragraph"><p>Cypher est inspiré de plusieurs approches et construit sur des pratiques
établies pour le requêtage expressif. La plupart des mots clefs comme
<code>WHERE</code> et <code>ORDER BY</code> sont inspirés de
<a href="http://fr.wikipedia.org/wiki/Structured_Query_Language">SQL</a>. La concordance
de patterns emprunte les approches d&#8217;expression de
<a href="http://fr.wikipedia.org/wiki/SPARQL">SPARQL</a>.</p></div>
<div class="paragraph"><p>En étant un langage déclaratif, Cypher se concentre sur la clarté d&#8217;exprimer
<em>quoi</em> retrouver dans un graphe et non <em>comment</em> le faire. Ceci est en
contraste aux langages impératifs comme Java et aux langages script comme
<a href="http://gremlin.tinkerpop.com">Gremlin</a> (supporté via le <a href="#gremlin-plugin">[gremlin-plugin]</a>)
et <a href="http://neo4j.rubyforge.org/">the JRuby Neo4j bindings</a>. Ce qui rend le
fait d&#8217;optimisation de requêtes un détail d&#8217;implémentation non exposé aux
utilisateurs.</p></div>
<div class="paragraph"><p>Le langage de requêtage comporte un nombre de clauses distinctes.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>START</code>: Points de départ dans le graphe, obtenus via un lookup d&#8217;index ou
  via des ID d'éléments.
</p>
</li>
<li>
<p>
<code>MATCH</code>: Le pattern du graphe à correspondre, lié aux points de départ dans
  <code>START</code>.
</p>
</li>
<li>
<p>
<code>WHERE</code>: Critère de filtrage.
</p>
</li>
<li>
<p>
<code>RETURN</code>: Ce qu&#8217;il faut retourner.
</p>
</li>
<li>
<p>
<code>CREATE</code>: Crée des noeuds ou des relations.
</p>
</li>
<li>
<p>
<code>DELETE</code>: Efface des noeuds, relations ou propriétés.
</p>
</li>
<li>
<p>
<code>SET</code>: Affecte des valeurs aux propriétés.
</p>
</li>
<li>
<p>
<code>FOREACH</code>: Effectue des actions de mise à jour une fois par élément dans une
  liste.
</p>
</li>
<li>
<p>
<code>WITH</code>: Divise une requête en de multiples parties distinctes.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Voyons voir trois d&#8217;entre elles en action.</p></div>
<div class="paragraph"><p>Imaginez un exemple de graphe comme le suivant:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/Example-Graph-cypher-intro.svg" alt="Example-Graph-cypher-intro.svg" />
</div>
<div class="title">Figure 11. Graphe Exemple</div>
</div>
<div class="paragraph"><p>Par exemple, ici une requête qui trouve un utilisateur nommé John dans un
index et traverse le graphe afin de trouver les amis de John (mais pas ses
amis directs) en retournant John et les amis des amis de John.</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START john=node:node_auto_index(name = 'John')
MATCH john-[:friend]-&gt;()-[:friend]-&gt;fof
RETURN john, fof</pre></div>
<div class="paragraph"><p>Résultant en:</p></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">john</td><td align="left" valign="top">fof</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows
</th></tr><tr><th align="left" valign="top" colspan="2">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"John"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Maria"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"John"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Steve"}</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>A présent, nous allons ajouter un filtrage afin de voir plus de parties en
mouvement:</p></div>
<div class="paragraph"><p>Dans cet exemple, nous prenons une liste d&#8217;utilisateurs (par ID de noeud) et
traversons le graphe en recherchant les autres utilisateurs qui ont une
relation sortante <code>friend</code>, retournant seulement les utilisateurs parcourus
qui ont une propriété <code>name</code> commençant par un <code>S</code>.</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START user=node(5,4,1,2,3)
MATCH user-[:friend]-&gt;follower
WHERE follower.name =~ 'S.*'
RETURN user, follower.name</pre></div>
<div class="paragraph"><p>Résultant en:</p></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">user</td><td align="left" valign="top">follower.name</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Joe"}</code></p></td><td align="left" valign="top"><p><code class="literal">"Steve"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"John"}</code></p></td><td align="left" valign="top"><p><code class="literal">"Sara"</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>Pour utiliser Cypher depuis Java, voyez <a href="#tutorials-cypher-java">[tutorials-cypher-java]</a>.  Pour
plus d&#8217;exemples Cypher, voyez aussi <a href="#data-modeling-examples">[data-modeling-examples]</a>.</p></div>
<div class="sect2">
<h3 id="query-operators">Opérateurs</h3>
<div class="sect3">
<h4 id="query-operators-mathematical">Mathematical operators</h4>
<div class="paragraph"><p>The mathematical operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>.</p></div>
</div>
<div class="sect3">
<h4 id="query-operators-comparison">Comparison operators</h4>
<div class="paragraph"><p>The comparison operators are <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p></div>
</div>
<div class="sect3">
<h4 id="query-operators-string">String operators</h4>
<div class="paragraph"><p>Strings can be concatenated using the <code>+</code> operator.</p></div>
</div>
<div class="sect3">
<h4 id="query-operators-collection">Collection operators</h4>
<div class="paragraph"><p>Collections can be concatenated using the <code>+</code> operator.</p></div>
</div>
<div class="sect3">
<h4 id="query-operators-property">Property operators</h4>
<div class="paragraph"><p>Since Neo4j is a schema-free graph database, Cypher has two special
operators: <code>?</code> and <code>!</code>.</p></div>
<div class="paragraph"><p>They are used on properties, and are used to deal with missing values.  A
comparison on a property that does not exist would normally cause an error.
Instead of having to always check if the property exists before comparing
its value with something else, the special property operators can be used.
The question mark makes the comparison always return true if the property is
missing, and the exclamation mark makes the comparator return false.</p></div>
<div class="paragraph"><p>Ce prédicat évaluera à vrai si <code>n.prop</code> est manquant.</p></div>
<div class="paragraph"><p><code>WHERE n.prop? = "foo"</code></p></div>
<div class="paragraph"><p>Ce prédicat évaluera à faux si +n.prop. est manquant.</p></div>
<div class="paragraph"><p><code>WHERE n.prop! = "foo"</code></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Attention</div>
</td>
<td class="content">Mixer les deux dans une même comparaison peut mener à des résultats non
prévisibles.</td>
</tr></table>
</div>
<div class="paragraph"><p>C&#8217;est vraiment un jeu d&#8217;enfant quand on voit ce qui en ressort:</p></div>
<div class="paragraph"><p><code>WHERE n.prop? = "foo"</code> &#8658; <code>WHERE (not(has(n.prop)) OR n.prop = "foo")</code></p></div>
<div class="paragraph"><p><code>WHERE n.prop! = "foo"</code> &#8658; <code>WHERE (has(n.prop) AND n.prop = "foo")</code></p></div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-expressions">Expressions</h3>
<div class="sect3">
<h4 id="_expressions_in_general">Expressions in general</h4>
<div class="paragraph"><p>Une expression dans Cypher peut être:</p></div>
<div class="ulist"><ul>
<li>
<p>
Un littérale numérique (integer ou double): <code>13</code>, <code>40000</code>, <code>3.14</code>.
</p>
</li>
<li>
<p>
Une chaîne littérale: <code>"Hello"</code>, <code>'World'</code>.
</p>
</li>
<li>
<p>
Un booléen littérale: <code>true</code>, <code>false</code>, <code>TRUE</code>, <code>FALSE</code>.
</p>
</li>
<li>
<p>
Un identifiant: <code>n</code>, <code>x</code>, <code>rel</code>, <code>myFancyIdentifier</code>, <code>`Un nom avec plein
  de jam dedans[]!`</code>.
</p>
</li>
<li>
<p>
Une propriété: <code>n.prop</code>, <code>x.prop</code>, <code>rel.thisProperty</code>,
  <code>myFancyIdentifier.`(nom de propriété bizarre)`</code>.
</p>
</li>
<li>
<p>
Une propriété qui peut être null: C&#8217;est une propriété avec un point
  d&#8217;interrogation ou un point d&#8217;exclamation&#8201;&#8212;&#8201;<code>n.prop?</code>, <code>rel.thisProperty!</code>.
</p>
</li>
<li>
<p>
Un paramètre: <code>{param}</code>, <code>{0}</code>
</p>
</li>
<li>
<p>
Une collection d&#8217;expressions: <code>["a", "b"]</code>, <code>[1,2,3]</code>, <code>["a", 2, n.property,
  {param}]</code>, <code>[ ]</code>.
</p>
</li>
<li>
<p>
Un appel de fonction: <code>length(p)</code>, <code>nodes(p)</code>.
</p>
</li>
<li>
<p>
Une fonction d&#8217;agrégation: <code>avg(x.prop)</code>, <code>count(*)</code>.
</p>
</li>
<li>
<p>
Des types de relations: <code>:REL_TYPE</code>, <code>:`REL TYPE`</code>, <code>:REL1|REL2</code>.
</p>
</li>
<li>
<p>
Un pattern de chemin: <code>a--&gt;()&lt;--b</code>.
</p>
</li>
<li>
<p>
Un prédication d&#8217;expression est une expression qui retourne vrai ou faux:
  a.prop = "Hello", length(p) &gt; 10, has(a.name)
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_note_sur_les_chaînes_littérales">Note sur les chaînes littérales</h4>
<div class="paragraph"><p>Les chaînes littérales peuvent contenir ces séquences d'échappement.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="right" valign="top">Séquence d'échappement</th>
<th align="left" valign="top">Caractère</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table"><code>\t</code></p></td>
<td align="left" valign="top"><p class="table">Tabulation</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\b</code></p></td>
<td align="left" valign="top"><p class="table">Retour</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\n</code></p></td>
<td align="left" valign="top"><p class="table">Nouvelle ligne</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\r</code></p></td>
<td align="left" valign="top"><p class="table">Retour chariot</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\f</code></p></td>
<td align="left" valign="top"><p class="table">Form feed</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\'</code></p></td>
<td align="left" valign="top"><p class="table">Guillemet simple</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\"</code></p></td>
<td align="left" valign="top"><p class="table">Guillemet double</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><code>\\</code></p></td>
<td align="left" valign="top"><p class="table">Barre oblique inversée</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-parameters">Paramètres</h3>
<div class="paragraph"><p>Cypher supporte le requêtage avec paramètres. Cela permet aux développeurs
de ne pas devoir construire de chaînes afin de créer une requête, cela
facilite également la mise en cache de plans d&#8217;exécution pour Cypher.</p></div>
<div class="paragraph"><p>Les paramètres peuvent être utilisés pour des littérales et expressions dans
la clause <code>WHERE</code>, pour la clé d&#8217;index et pour la valeur d&#8217;index dans la
clause <code>START</code>, les requêtes d&#8217;index et finalement pour les id de
noeuds/relations. Les paramètres ne peuvent pas être utilisés pour les noms
de propriétés du fait que la notation de propriétés fait partie de la
structure de requête qui est compilée dans le plan de requête.</p></div>
<div class="paragraph"><p>Les noms de paramètres peuvent contenir des lettres, des chiffres et
n&#8217;importe quelle combinaison de ceux-ci.</p></div>
<div class="paragraph"><p>Les exemples suivants démontrent comment vous pouvez utiliser les paramètres
en Java.</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "id", 0 );
ExecutionResult result = engine.execute( "start n=node({id}) return n.name", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "node", andreasNode );
ExecutionResult result = engine.execute( "start n=node({node}) return n.name", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "id", Arrays.asList( 0, 1, 2 ) );
ExecutionResult result = engine.execute( "start n=node({id}) return n.name", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "name", "Johan" );
ExecutionResult result =
        engine.execute( "start n=node(0,1,2) where n.name = {name} return n", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "key", "name" );
params.put( "value", "Michaela" );
ExecutionResult result =
        engine.execute( "start n=node:people({key} = {value}) return n", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "query", "name:Andreas" );
ExecutionResult result = engine.execute( "start n=node:people({query}) return n", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "s", 1 );
params.put( "l", 1 );
ExecutionResult result =
        engine.execute( "start n=node(0,1,2) return n.name skip {s} limit {l}", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> params = new HashMap<String, Object>();
params.put( "regex", ".*h.*" );
ExecutionResult result =
        engine.execute( "start n=node(0,1,2) where n.name =~ {regex} return n.name", params );</pre>
</div></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> n1 = new HashMap<String, Object>();
n1.put( "name", "Andres" );
n1.put( "position", "Developer" );

Map<String, Object> params = new HashMap<String, Object>();
params.put( "props", n1 );
engine.execute( "START n=node(0) SET n = {props}", params );</pre>
</div></div>
</div>
<div class="sect2">
<h3 id="cypher-identifiers">Identifiants</h3>
<div class="paragraph"><p>Quand vous référencez des parties du pattern, vous le faites en les
nommant. Les noms que vous donnez aux différentes parties sont appelés des
identifiants.</p></div>
<div class="paragraph"><p>Dans cet exemple:</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START n=node(1) MATCH n--&gt;b RETURN b</pre></div>
<div class="paragraph"><p>Les identifiants sont <code>n</code> et <code>b</code>.</p></div>
<div class="paragraph"><p>Les noms d&#8217;identifiants sont sensibles à la casse et peuvent contenir des
underscores et des caractères alphanumériques (a-z, 0-9) mais doivent
commencer par une lettre. Si d&#8217;autres caractères sont nécessaires, vous
pouvez utiliser l&#8217;identifiant en utilisant le guillemet inverse (<code>`</code>).</p></div>
<div class="paragraph"><p>Les mêmes règles s&#8217;appliquent aux noms de propriétés.</p></div>
</div>
<div class="sect2">
<h3 id="cypher-comments">Commentaires</h3>
<div class="paragraph"><p>Pour ajouter des commentaires dans vos requêtes, utilisez des doubles barres
obliques. Exemples:</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START n=node(1) RETURN n //This is an end of line comment</pre></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START n=node(1)
//This is a whole line comment
RETURN n</pre></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START n=node(1) WHERE n.property = "//This is NOT a comment" RETURN n</pre></div>
</div>
<div class="sect2">
<h3 id="query-updating">Mise à jour du graphe</h3>
<div class="paragraph"><p>Cypher peut être utilisé aussi bien pour requêter que pour mettre à jour le
graphe.</p></div>
<div class="sect3">
<h4 id="_la_structure_de_requêtes_de_mise_à_jour">La Structure de Requêtes de Mise à Jour</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">Info flash</div>
<div class="ulist"><ul>
<li>
<p>
Une partie de requête Cypher peut très bien trouver dans le graphe et le
  mettre à jour en même temps.
</p>
</li>
<li>
<p>
Chaque partie peut également lire et trouver dans le graphe, ou même le
  mettre à jour.
</p>
</li>
</ul></div>
</div></div>
<div class="paragraph"><p>Si vous lisez dans le graphe et que vous le mettez ensuite à jour, votre
requête contient implicitement deux parties&#8201;&#8212;&#8201;la lecture est la première
partie et l'écriture la seconde. Si votre requête est une simple lecture,
Cypher sera fainéant et ne fera pas de pattern matching tant que vous ne
demandiez de résultats en retour. Ici la sémantique est que <em>toutes</em> les
lectures seront effectuées avant n&#8217;importe quelle écriture. Ceci est très
important! Sans cela il est facile de trouver des cas où le pattern matcher
rencontrera des données qui ont été créées par cette même requête et toutes
les prédictions sont réduites à néant. Cette route mène à Heisenbugs, au
mouvement Brownien et les chats qui sont morts et en vie en même temps.</p></div>
<div class="paragraph"><p>D&#8217;abord lire, ensuite écrire est le seul pattern où les parties de requêtes
sont implicites&#8201;&#8212;&#8201;tout autre ordre et vous devez être explicite à propos de
vos parties de requêtes. Les parties sont séparées en utilisant le <code>WITH</code>.
<code>WITH</code> est comme l&#8217;horizon&#8201;&#8212;&#8201;c&#8217;est une barrière entre un plan et
l&#8217;exécution de ce plan.</p></div>
<div class="paragraph"><p>Quand vous voulez filtrer en utilisant des données agrégées, vous devez lier
ensemble deux parties de requêtes&#8201;&#8212;&#8201;la première fait l&#8217;agrégation et la
suivant filtre sur les données venant de la première.</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">START n=node(...)
MATCH n-[:friend]-friend
WITH n, count(friend) as friendsCount
WHERE friendsCount &gt; 3
RETURN n, friendsCount</pre></div>
<div class="paragraph"><p>En utilisant le <code>WITH</code>, vous spécifiez comment vous voulez que l&#8217;agrégation
se fasse et cette agrégation doit être finie avant que Cypher commence son
filtrage.</p></div>
<div class="paragraph"><p>Vous pouvez lier ensemble autant de parties de requêtes que vous désirez si
vous avez un heap JVM pour.</p></div>
</div>
<div class="sect3">
<h4 id="_retourner_des_données">Retourner des données</h4>
<div class="paragraph"><p>Chaque requête peut retourner des données. Si votre requête ne fait que lire, elle doit retourner des données&#8201;&#8212;&#8201;cela n&#8217;a pas de but si elle ne retourne rien et ne sera pas considérée comme requête Cypher valide. Les requêtes qui mettent à jour le graphe ne doivent pas nécessairement retourner des données, mais peuvent.
Après toutes les parties d&#8217;une requête vient le déclaratif final
<code>RETURN</code>. <code>RETURN</code> ne fait partie d&#8217;aucune partie de requête&#8201;&#8212;&#8201;c&#8217;est une
virgule après les parties de requête. Quand <code>RETURN</code> est autorisé, il est
aussi autorisé d&#8217;utiliser <code>SKIP</code>/<code>LIMIT</code> et <code>ORDER BY</code>.</p></div>
<div class="paragraph"><p>Si vous retournez des éléments d&#8217;un graphe qui viennent juste d'être supprimés&#8201;&#8212;&#8201;faites attention, vous détenez un pointeur qui n&#8217;est plus valide. Des opérations sur ce noeud peuvent échouer mystérieusement et imprévisiblement.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="query-transactions">Transactions</h3>
<div class="paragraph"><p>Chaque requête qui met le graphe à jour doivent s&#8217;effectuer dans une
transaction. Chaque requête de mise à jour sera toujours soit complètement
réussie, soit complètement échouée.</p></div>
<div class="paragraph"><p>Cypher créera une nouvelle transaction et la commitera une fois que la
requête est terminée. Ou si une transaction existe déjà dans le contexte
courant, la requête sera exécutée dedans et rien ne sera persisté sur le
disque tant que la transaction n&#8217;est pas commitée.</p></div>
<div class="paragraph"><p>Ceci peut être utilisé afin d&#8217;avoir plusieurs requêtes committées comme une
seule transaction:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Ouvrir une transaction,
</p>
</li>
<li>
<p>
effectue plusieurs requêtes Cypher de mise à jour
</p>
</li>
<li>
<p>
et les commiter toutes en même temps.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Notez qu&#8217;une requête retiendra tous les changements dans le heap tant que
toute la requête ait fini de s&#8217;exécuter. Une grande requête aura pour
conséquence de nécessiter une JVM avec beaucoup d&#8217;espace de heap.</p></div>
</div>
<div class="sect2">
<h3 id="introduction-pattern">Patterns</h3>
<div class="paragraph"><p>Les patterns sont au coeur de Cypher et sont utilisés à beaucoup
d&#8217;endroits. En utilisant les patterns, vous décrivez la forme des données
que vous recherchez. Les patterns sont utilisés dans la clause <code>MATCH</code>. Les
patterns de chemin sont des expressions. Comme ces expressions sont des
collections, elles peuvent également être utilisées comme prédicats (une
collection non vide signifie vrai). Ils sont également utilisés pour
<code>CREATE</code>/<code>CREATE UNIQUE</code> dans le graphe.</p></div>
<div class="paragraph"><p>Donc, la compréhension des patterns est important afin d'être efficace avec
Cypher.</p></div>
<div class="paragraph"><p>Vous décrivez le pattern et Cypher déterminera comment retrouver les données
pour vous. L&#8217;idée pour vous est de dessiner la requête sur un tableau blanc,
de nommer les parties intéressantes du pattern, ainsi vous pouvez utiliser
les valeurs de ces parties pour créer le jeu de résultats que vous
recherchez.</p></div>
<div class="paragraph"><p>Les patterns ont des points de liaison ou des points de départ. Ils sont les
parties du pattern qui ont déjà une ``liaison`` avec un jeu de noeuds ou
relations. Toutes les parties du pattern doivent être directement ou
indirectement connectées à un point de départ&#8201;&#8212;&#8201;un pattern où les parties
du pattern ne sont pas joignables depuis un point de départ seront rejetés.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<thead>
<tr>
<th align="right" valign="top">Clause</th>
<th align="center" valign="top">Optionnel</th>
<th align="center" valign="top">Types de rel. multiples</th>
<th align="center" valign="top">Longueur variable</th>
<th align="center" valign="top">Chemins</th>
<th align="center" valign="top">Maps</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table"><strong>Match</strong></p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><strong>Create</strong></p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><strong>Create Unique</strong></p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table"><strong>Expressions</strong></p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">Oui</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
<td align="center" valign="top"><p class="table">-</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_patterns_pour_les_noeuds_liés">Patterns pour les noeuds liés</h4>
<div class="paragraph"><p>La description des patterns est composée d&#8217;un ou plusieurs chemins, séparés
par une virgule. Un chemin est une séquence de noeuds et relations qui
démarrent et finissent toujours dans des noeuds. Un exemple serait:</p></div>
<div class="paragraph"><p><code><code>(a)--&gt;(b)</code></code></p></div>
<div class="paragraph"><p>C&#8217;est un chemin partant du pattern node <code>a</code>, avec une relation sortante vers
le pattern node <code>b</code>.</p></div>
<div class="paragraph"><p>Les chemins peuvent être d&#8217;une longueur arbitraire, et le même noeud peut
apparaître dans des endroits multiples de ce chemin.</p></div>
<div class="paragraph"><p>Les identifiants de noeuds peuvent être utilisés avec ou sans
parenthèses. La correspondance suivante est sémantique identique à celle que
nous avons vu plus haut&#8201;&#8212;&#8201;la différence est purement esthétique.</p></div>
<div class="paragraph"><p><code><code>a--&gt;b</code></code></p></div>
<div class="paragraph"><p>Si un noeud ne vous intéresse pas, vous n'êtes pas obligés de le nommé. Les
parenthèses vides sont utilisées pour ces noeuds, comme ceci:</p></div>
<div class="paragraph"><p><code><code>a--&gt;()&lt;--b</code></code></p></div>
</div>
<div class="sect3">
<h4 id="_travailler_avec_des_relations">Travailler avec des relations</h4>
<div class="paragraph"><p>Si vous devez travailler avec des relations entre deux noeuds, vous pouvez
les nommer.</p></div>
<div class="paragraph"><p><code><code>a-[r]-&gt;b</code></code></p></div>
<div class="paragraph"><p>Si la direction de la relation n&#8217;est pas importante, vous pouvez omettre la
flèche à n&#8217;importe quelle fin de la relation, comme ceci:</p></div>
<div class="paragraph"><p><code><code>a--b</code></code></p></div>
<div class="paragraph"><p>Les relations ont des types. Quand vous n'êtes intéressés que par un type de
relations spécifique, vous pouvez le spécifier comme ceci:</p></div>
<div class="paragraph"><p><code><code>a-[:REL_TYPE]-&gt;b</code></code></p></div>
<div class="paragraph"><p>Si plusieurs types de relations sont acceptables, vous pouvez les lister en
les séparant avec le symbol pipe <code>|</code> comme ceci:</p></div>
<div class="paragraph"><p><code><code>a-[r:TYPE1|TYPE2]-&gt;b</code></code></p></div>
<div class="paragraph"><p>Ce pattern fera correspondre une relation de type <code>TYPE1</code> ou <code>TYPE2</code>, allant
de <code>a</code> à <code>b</code>. La relation est nommée <code>r</code>. Des types de relations multiples
ne peuvent pas êtres utilisés avec <code>CREATE</code> ou <code>CREATE UNIQUE</code>.</p></div>
</div>
<div class="sect3">
<h4 id="_relations_optionnelles">Relations optionnelles</h4>
<div class="paragraph"><p>Une relation optionnelle est retournée si elle est trouvée, sinon elle sera
remplacée par <code>null</code>. Normalement, si aucune relation correspondante n&#8217;est
trouvée, ce sous-graphe n&#8217;est pas retourné. Des relations optionnelles dans
Cypher peuvent être comparées aux outer join dans SQL.</p></div>
<div class="paragraph"><p>Elles ne peuvent être utilisées que dans <code>MATCH</code>.</p></div>
<div class="paragraph"><p>Les relations optionnelles sont marquées avec un point
d&#8217;interrogation. Elles permettent d'écrire des requêtes comme ceci:</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START me=node(*)
MATCH me--&gt;friend-[?]-&gt;friend_of_friend
RETURN friend, friend_of_friend</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START me=node(*)
 MATCH me--&gt;friend-[?]-&gt;friend_of_friend
 RETURN friend, friend_of_friend</strong></span></p>
<div class="paragraph"><p>La requête plus haut dit ``pour chaque personne, donnes moi tous ses amis et
les amis de ses amis, si ils en ont.``</p></div>
<div class="paragraph"><p>L&#8217;option est transitive&#8201;&#8212;&#8201;si une partie du pattern peut seulement être
atteinte par un point lié via une relation optionnelle, cette partie est
aussi optionnelle. Dans le pattern ci-dessus, le seul point lié dans le
pattern est <code>me</code>. Du fait que les relations entre <code>friend</code> et <code>children</code>
sont optionnelles, <code>children</code> est une partie optionnelle du graphe.</p></div>
<div class="paragraph"><p>Les chemins qui contiennent des parties optionnelles sont également
optionnels&#8201;&#8212;&#8201;si une partie du chemin est <code>null</code>, tout le chemin sera
<code>null</code>.</p></div>
<div class="paragraph"><p>Dans les exemples suivants, <code>b</code> et <code>p</code> sont tous optionnels et peuvent
contenir <code>null</code>:</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?]-&gt;b
RETURN b</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START a=node(4)
 MATCH p = a-[?]-&gt;b
 RETURN b</strong></span></p>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?*]-&gt;b
RETURN b</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START a=node(4)
 MATCH p = a-[?*]-&gt;b
 RETURN b</strong></span></p>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START a=node(4)
MATCH p = a-[?]-&gt;x--&gt;b
RETURN b</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START a=node(4)
 MATCH p = a-[?]-&gt;x--&gt;b
 RETURN b</strong></span></p>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START a=node(4), x=node(3)
MATCH p = shortestPath( a-[?*]-&gt;x )
RETURN p</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START a=node(4), x=node(3)
 MATCH p = shortestPath( a-[?*]-&gt;x )
 RETURN p</strong></span></p>
</div>
<div class="sect3">
<h4 id="_contrôler_la_profondeur">Contrôler la profondeur</h4>
<div class="paragraph"><p>Un pattern de relation peut s'étendre à plusieurs relations du
graphe. Celles-ci sont appelées des relations à longueur variable, et sont
marquées comme ceci en utilisant un astérisque (<code>*</code>):</p></div>
<div class="paragraph"><p><code><code>(a)-[*]-&gt;(b)</code></code></p></div>
<div class="paragraph"><p>Ceci signifie un chemin partant du noeud du pattern <code>a</code>, suivant seulement
les relations sortant, jusqu'à ce qu&#8217;il atteigne un noeud du pattern
<code>b</code>. Toutes les relations peuvent être suivies en cherchant un chemin vers
<code>b</code>, ce qui peut résulter en une requête très gourmande dépendant de la
nature de votre graphe.</p></div>
<div class="paragraph"><p>Vous pouvez spécifier le nombre minimum d'étapes qui doivent être contenues
et/ou un nombre maximum d'étapes:</p></div>
<div class="paragraph"><p><code><code>(a)-[*3..5]-&gt;(b)</code></code></p></div>
<div class="paragraph"><p>Ceci est une relation à longueur variable contenant au moins trois relations
dans le graphe et au maximum cinq.</p></div>
<div class="paragraph"><p>Les relations à longueur variable ne peuvent pas être utilisées avec
<code>CREATE</code> et <code>CREATE UNIQUE</code>.</p></div>
<div class="paragraph"><p>Comme simple exemple, prenons la requête ci-dessous:</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START me=node(3)
MATCH me-[:KNOWS*1..2]-remote_friend
RETURN remote_friend</pre></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">remote_friend</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">0 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START me=node(3)
 MATCH me-[:KNOWS*1..2]-remote_friend
 RETURN remote_friend</strong></span></p>
<div class="paragraph"><p>Cette requête part d&#8217;un noeud et suit les relations <code>KNOWS</code> deux ou trois
pas plus loin et ensuite s&#8217;arrête.</p></div>
</div>
<div class="sect3">
<h4 id="_assigner_un_chemin_à_un_identifiant_de_chemin">Assigner un chemin à un identifiant de chemin</h4>
<div class="paragraph"><p>Dans une base de données graphe, un chemin est un concept important. Un
chemin est une collection de noeuds et de relations qui décrivent un chemin
dans le graphe. Afin d&#8217;assigner un chemin à un identifant de chemin, vous
assignez simplement un pattern de chemin à un identifiant, comme ceci:</p></div>
<div class="paragraph"><p><code><code>p = (a)-[*3..5]-&gt;(b)</code></code></p></div>
<div class="paragraph"><p>Vous pouvez le faire avec <code>MATCH</code>, <code>CREATE</code> et <code>CREATE UNIQUE</code>, mais pas
quand vous utilisez des patterns comme expressions. Un exemple des trois en
une seule requête:</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START me=node(3)
MATCH p1 = me-[*2]-friendOfFriend
CREATE p2 = me-[:MARRIED_TO]-(wife {name:"Gunhild"})
CREATE UNIQUE p3 = wife-[:KNOWS]-friendOfFriend
RETURN p1,p2,p3</pre></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"Dilshad"}
(2) {"name":"Emil"}
(3) {"name":"Filipa"}
(4) {"name":"Anders"}
(5) {"name":"Becky"}
(6) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(6) {}
(4)-[:KNOWS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
(6)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>START me=node(3)
 MATCH p1 = me-[*2]-friendOfFriend
 CREATE p2 = me-[:MARRIED_TO]-(wife {name:"Gunhild"})
 CREATE UNIQUE p3 = wife-[:KNOWS]-friendOfFriend
 RETURN p1,p2,p3</strong></span></p>
</div>
<div class="sect3">
<h4 id="_ajouter_des_propriétés">Ajouter des propriétés</h4>
<div class="paragraph"><p>Les noeuds et relations sont importants, mais Neo4j utilise des propriétés
sur les deux afin d&#8217;avoir des modèles graphes à grande densité.</p></div>
<div class="paragraph"><p>Les propriétés sont exprimées dans les patterns en utilisant une map de
construction, qui est simplement des accolades entourant un nombre de paires
clé-valeur séparées par une virgule, par ex.  <code>{ name: "Andres", sport:
"BJJ" }</code>. Si la map est fournie en tant que paramètre, l&#8217;expression normale
de paramètre est utilisée: <code>{ paramName }</code>.</p></div>
<div class="paragraph"><p>Les maps sont seulement utilisées par <code>CREATE</code> et <code>CREATE UNIQUE</code>. Avec
<code>CREATE</code> ils sont utilisés pour assigner les propriétés aux noeuds et
relations nouvellement créés.</p></div>
<div class="paragraph"><p>Quand ils sont utilisés avec <code>CREATE UNIQUE</code>, ils sont utilisés afin de
faire correspondre un élément de pattern avec un élément de graphe. La
correspondance est correcte si les propriétés de l'élément de pattern
correspondent exactement aux propriétés d&#8217;un élément de graphe. L'élément de
graphe peut avoir des propriétés additionnelles et ils n&#8217;affectent pas la
correspondance. Si Neo4j échoue à trouve des éléments de graphe
correspondants, les maps sont utilisés pour affecter les valeurs aux
nouveaux éléments créés.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="query-plans">Viewing Execution Plans</h3>
<div class="paragraph"><p>Cypher works very hard to execute queries as fast as possible. However, when optimizing for maximum query
execution performance, it may be helpful to rephrase queries using knowledge about the domain and the application.</p></div>
<div class="paragraph"><p>The overall goal of manual query performance optimization is to ensure that only necessary data is retrieved from the
graph or at least that data gets filtered out as early as possible in order to reduce the amount of work that has to
be done at later stages of query execution.</p></div>
<div class="paragraph"><p>In order to be able to do this manual optimization, it is necessary to understand how a given query is going
to be executed.</p></div>
<div class="paragraph"><p>Each Cypher query gets transformed into an execution plan by the Cypher execution engine. The execution plan consists of
a series of execution steps called pipes which may produce data, transform it, or even update the database or the schema.
Data enters the execution at one pipe and is passed on from pipe to pipe until it either is filtered out, transformed,
or returned to the user.</p></div>
<div class="paragraph"><p>To look at the execution plan description used to satisfy your query, you can look at the execution plan description on
the execution result object returned by the Java Core API.</p></div>
</div>
<div class="sect2">
<h3 id="query-start">Start</h3>
<div class="paragraph"><p>Chaque requête décrit un pattern, et dans ce pattern il peut il y avoir
plusieurs points de départ. Un point de départ est une relation ou un noeud
où un pattern est ancré. Vous pouvez introduire des points de départ comme
id ou par lookup d&#8217;index. Notez qu&#8217;essayer d&#8217;utiliser un index qui n&#8217;existe
pas déclenchera une exception.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-start-graph.svg" alt="cypher-start-graph.svg" />
</div>
<div class="title">Figure 12. Graph</div>
</div>
<div class="sect3">
<h4 id="start-node-by-id">Noeud par id</h4>
<div class="paragraph"><p>Binding a node as a starting point is done with the <code>node(*)</code> function.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Neo4j reuses its internal ids when nodes and relationships are deleted,
which means it&#8217;s bad practice to refer to them this way. Instead, use
application generated ids.</td>
</tr></table>
</div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN n</pre></div>
<div class="paragraph"><p>Le noeud correspondant est retourné.</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"A"}
(2) {"name":"B"}
(3) {"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(1) return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="start-relationship-by-id">Relation par id</h4>
<div class="paragraph"><p>Binding a relationship as a starting point is done with the
<code>relationship(*)</code> function, which can also be abbreviated <code>rel(*)</code>. See
<a href="#start-node-by-id">[start-node-by-id]</a> for more information on Neo4j ids.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START r=relationship(0)
RETURN r</pre></div>
<div class="paragraph"><p>La relation avec id <code>0</code> est retournée.</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"A"}
(2) {"name":"B"}
(3) {"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start r=relationship(0) return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="start-multiple-nodes-by-id">Noeuds multiples par ids</h4>
<div class="paragraph"><p>Les noeuds multiples sont sélectionnés en les listant et les séparant avec
une virgule.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START n=node(1, 2, 3)
RETURN n</pre></div>
<div class="paragraph"><p>Ceci retourne les noeuds listés dans le déclaratif <code>START</code></p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"A"}
(2) {"name":"B"}
(3) {"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(1, 2, 3) return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="start-all-nodes">Tous les noeuds</h4>
<div class="paragraph"><p>Pour retourner tous les noeuds, utilisez un astérisque. Ceci peut être
utilisé également sur les relations.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START n=node(*)
RETURN n</pre></div>
<div class="paragraph"><p>Cette requête retourne tous les noeuds du graphe.</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"A"}
(2) {"name":"B"}
(3) {"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(*) return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="start-node-by-index-lookup">Noeud par lookup d&#8217;index</h4>
<div class="paragraph"><p>Quand le point de départ peut être retrouvé par un lookup d&#8217;index, cela se
fait ainsi: <code>node:index-name(key = "value")</code>. Dans cet exemple, un index
nommé <code>nodes</code> existe.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START n=node:nodes(name = "A")
RETURN n</pre></div>
<div class="paragraph"><p>La requête retourne le noeud indexé avec le nom "<code>A</code>".</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td></tr></tbody></table></div></div>
</div>
<div class="sect3">
<h4 id="start-relationship-by-index-lookup">Relationship by index lookup</h4>
<div class="paragraph"><p>When the starting point can be found by using index lookups, it can be done like this: <code>relationship:index-name(key = "value")</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START r=relationship:rels(name = "Andrés")
RETURN r</pre></div>
<div class="paragraph"><p>The relationship indexed with the <code>name</code> property set to "<code>Andrés</code>" is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {name:"Andrés"</code></p></td></tr></tbody></table></div></div>
</div>
<div class="sect3">
<h4 id="start-node-by-index-query">Noeud par requête d&#8217;index</h4>
<div class="paragraph"><p>Quand le point de départ peut être trouvé par plusieurs requêtes Lucene
complexes, la syntaxe à utiliser est la suivante :
<code>node:index-name("query")</code>. Cela vous permet d'écrire des requêtes d&#8217;index
plus avancées.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START n=node:nodes("name:A")
RETURN n</pre></div>
<div class="paragraph"><p>The node indexed with name "A" is returned by the query.</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td></tr></tbody></table></div></div>
</div>
<div class="sect3">
<h4 id="start-multiple-starting-points">Multiple starting points</h4>
<div class="paragraph"><p>Sometimes you want to bind multiple starting points. Just list them
separated by commas.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">START a=node(1), b=node(2)
RETURN a,b</pre></div>
<div class="paragraph"><p>Both the nodes <code>A</code> and the <code>B</code> are returned.</p></div>
<div class="openblock">
<div class="title">Résultat</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">b</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Essayez cette requête en live</b><span class="database">(1) {"name":"A"}
(2) {"name":"B"}
(3) {"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start a=node(1), b=node(2) return a,b</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-match">Match</h3>
<div class="sect3">
<h4 id="_introduction">Introduction</h4>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Dans la clause <code>MATCH</code>, les patterns sont beaucoup utilisés. Lisez
<a href="#introduction-pattern">[introduction-pattern]</a> pour une introduction.</td>
</tr></table>
</div>
<div class="paragraph"><p>Le graphe suivant est utilisé pour les exemples:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-match-graph.svg" alt="cypher-match-graph.svg" />
</div>
<div class="title">Figure 13. Graph</div>
</div>
</div>
<div class="sect3">
<h4 id="match-related-nodes">Related nodes</h4>
<div class="paragraph"><p>The symbol <code>--</code> means <em>related to,</em> without regard to type or direction.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)--(x)
RETURN x</pre></div>
<div class="paragraph"><p>All nodes related to A (Anders) are returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)--(x) return x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-outgoing-relationships">Outgoing relationships</h4>
<div class="paragraph"><p>When the direction of a relationship is interesting, it is shown by using <code>--&gt;</code> or <code>&lt;--</code>, like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)--&gt;(x)
RETURN x</pre></div>
<div class="paragraph"><p>All nodes that A has outgoing relationships to are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)--&gt;(x) return x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-directed-relationships-and-identifier">Directed relationships and identifier</h4>
<div class="paragraph"><p>If an identifier is needed, either for filtering on properties of the relationship, or to return the relationship, this is how you introduce the identifier.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r]-&gt;()
RETURN r</pre></div>
<div class="paragraph"><p>The query returns all outgoing relationships from node A.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:BLOCKS[1] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[r]-&gt;() return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-match-by-relationship-type">Match by relationship type</h4>
<div class="paragraph"><p>When you know the relationship type you want to match on, you can specify it by using a colon together with the relationship type.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[:BLOCKS]-&gt;(x)
RETURN x</pre></div>
<div class="paragraph"><p>All nodes that are BLOCKed by A are returned by this query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[:BLOCKS]-&gt;(x) return x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-match-by-multiple-relationship-types">Match by multiple relationship types</h4>
<div class="paragraph"><p>To match on one of multiple types, you can specify this by chaining them together with the pipe symbol <code>|</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[:BLOCKS|KNOWS]-&gt;(x)
RETURN x</pre></div>
<div class="paragraph"><p>All nodes with a <code>BLOCK</code> or <code>KNOWS</code> relationship to A are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[:BLOCKS|KNOWS]-&gt;(x) return x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-match-by-relationship-type-and-use-an-identifier">Match by relationship type and use an identifier</h4>
<div class="paragraph"><p>If you both want to introduce an identifier to hold the relationship, and specify the relationship type you want, just add them both, like this.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r:BLOCKS]-&gt;()
RETURN r</pre></div>
<div class="paragraph"><p>All <code>BLOCKS</code> relationships going out from A are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:BLOCKS[1] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[r:BLOCKS]-&gt;() return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-relationship-types-with-uncommon-characters">Relationship types with uncommon characters</h4>
<div class="paragraph"><p>Sometime your database will have types with non-letter characters, or with spaces in them. Use <code>`</code> (backtick) to quote these.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r:`TYPE THAT HAS SPACE IN IT`]-&gt;()
RETURN r</pre></div>
<div class="paragraph"><p>This query returns a relationship of a type with spaces in it.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:TYPE THAT HAS SPACE IN IT[6] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(3)-[:TYPE THAT HAS SPACE IN IT]-&gt;(3) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[r:`TYPE THAT HAS SPACE IN IT`]-&gt;() return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-multiple-relationships">Multiple relationships</h4>
<div class="paragraph"><p>Relationships can be expressed by using multiple statements in the form of <code>()--()</code>, or they can be strung together, like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c)
RETURN a,b,c</pre></div>
<div class="paragraph"><p>The three nodes in the path are returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">b</td><td align="left" valign="top">c</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="3">1 row
</th></tr><tr><th align="left" valign="top" colspan="3">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3) match (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c) return a,b,c</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-variable-length-relationships">Variable length relationships</h4>
<div class="paragraph"><p>Nodes that are a variable number of relationship&#8594;node hops away can be found using the following syntax: <code>-[:TYPE*minHops..maxHops]-&gt;</code>. minHops and maxHops are optional and default to 1 and infinity respectively. When no bounds are given the dots may be omitted.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), x=node(2, 4)
MATCH a-[:KNOWS*1..3]-&gt;x
RETURN a,x</pre></div>
<div class="paragraph"><p>This query returns the start and end point, if there is a path between 1 and 3 relationships away.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3), x=node(2, 4) match a-[:KNOWS*1..3]-&gt;x return a,x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-relationship-identifier-in-variable-length-relationships">Relationship identifier in variable length relationships</h4>
<div class="paragraph"><p>When the connection between two nodes is of variable length, a relationship identifier becomes an collection of relationships.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), x=node(2, 4)
MATCH a-[r:KNOWS*1..3]-&gt;x
RETURN r</pre></div>
<div class="paragraph"><p>The query returns the relationships, if there is a path between 1 and 3 relationships away.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[:KNOWS[0] {},:KNOWS[3] {}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[:KNOWS[0] {}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3), x=node(2, 4) match a-[r:KNOWS*1..3]-&gt;x return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-zero-length-paths">Zero length paths</h4>
<div class="paragraph"><p>Using variable length paths that have the lower bound zero means that two identifiers can point to the same node. If the distance between two nodes is zero, they are by definition the same node. Note that when matching zero length paths the result may contain a match even when matching on a relationship type not in use.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH p1=a-[:KNOWS*0..1]-&gt;b, p2=b-[:BLOCKS*0..1]-&gt;c
RETURN a,b,c, length(p1), length(p2)</pre></div>
<div class="paragraph"><p>This query will return four paths, some of which have length zero.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">b</td><td align="left" valign="top">c</td><td align="left" valign="top">length(p1)</td><td align="left" valign="top">length(p2)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="5">4 rows
</th></tr><tr><th align="left" valign="top" colspan="5">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3) match p1=a-[:KNOWS*0..1]-&gt;b, p2=b-[:BLOCKS*0..1]-&gt;c return a,b,c, length(p1), length(p2)</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-optional-relationship">Optional relationship</h4>
<div class="paragraph"><p>If a relationship is optional, it can be marked with a question mark. This is similar to how a SQL outer join works. If the relationship is there, it is returned. If it&#8217;s not, <code>null</code> is returned in it&#8217;s place. Remember that anything hanging off an optional relationship, is in turn optional, unless it is connected with a bound node through some other path.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
MATCH a-[?]-&gt;x
RETURN a,x</pre></div>
<div class="paragraph"><p>A node, and <code>null</code> are returned, since the node has no outgoing relationships.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(2) match a-[?]-&gt;x return a,x</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-optional-typed-and-named-relationship">Optional typed and named relationship</h4>
<div class="paragraph"><p>Just as with a normal relationship, you can decide which identifier it goes into, and what relationship type you need.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH a-[r?:LOVES]-&gt;()
RETURN a,r</pre></div>
<div class="paragraph"><p>This returns a node, and <code>null</code>, since the node has no outgoing <code>LOVES</code> relationships.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3) match a-[r?:LOVES]-&gt;() return a,r</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-properties-on-optional-elements">Properties on optional elements</h4>
<div class="paragraph"><p>Returning a property from an optional element that is <code>null</code> will also return <code>null</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
MATCH a-[?]-&gt;x
RETURN x, x.name</pre></div>
<div class="paragraph"><p>This returns the element x (<code>null</code> in this query), and <code>null</code> as it&#8217;s name.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td><td align="left" valign="top">x.name</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(2) match a-[?]-&gt;x return x, x.name</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-complex-matching">Complex matching</h4>
<div class="paragraph"><p>Using Cypher, you can also express more complex patterns to match on, like a diamond shape pattern.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c), (a)-[:BLOCKS]-(d)-[:KNOWS]-(c)
RETURN a,b,c,d</pre></div>
<div class="paragraph"><p>This returns the four nodes in the paths.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">b</td><td align="left" valign="top">c</td><td align="left" valign="top">d</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="4">1 row
</th></tr><tr><th align="left" valign="top" colspan="4">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Emil"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3)
 match (a)-[:KNOWS]-&gt;(b)-[:KNOWS]-&gt;(c), (a)-[:BLOCKS]-(d)-[:KNOWS]-(c)
 return a,b,c,d</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-shortest-path">Shortest path</h4>
<div class="paragraph"><p>Finding a single shortest path between two nodes is as easy as using the <code>shortestPath</code> function. It&#8217;s done like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START d=node(1), e=node(2)
MATCH p = shortestPath( d-[*..15]-&gt;e )
RETURN p</pre></div>
<div class="paragraph"><p>This means: find a single shortest path between two nodes, as long as the path is max 15 relationships long. Inside of the parenthesis
 you define a single link of a path&#8201;&#8212;&#8201;the starting node, the connecting relationship and the end node. Characteristics describing the relationship
 like relationship type, max hops and direction are all used when finding the shortest path. You can also mark the path as optional.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"},:KNOWS[3] {},Node[2]{name:"Emil"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start d=node(1), e=node(2) match p = shortestPath( d-[*..15]-&gt;e ) return p</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-all-shortest-paths">All shortest paths</h4>
<div class="paragraph"><p>Finds all the shortest paths between two nodes.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START d=node(1), e=node(2)
MATCH p = allShortestPaths( d-[*..15]-&gt;e )
RETURN p</pre></div>
<div class="paragraph"><p>This example will find the two directed paths between David and Emil.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"},:KNOWS[3] {},Node[2]{name:"Emil"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"David"},:KNOWS[2] {},Node[3]{name:"Anders"},:BLOCKS[1] {},Node[5]{name:"Cesar"},:KNOWS[4] {},Node[2]{name:"Emil"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start d=node(1), e=node(2) match p = allShortestPaths( d-[*..15]-&gt;e ) return p</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-named-path">Named path</h4>
<div class="paragraph"><p>If you want to return or filter on a path in your pattern graph, you can a introduce a named path.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH p = a--&gt;b
RETURN p</pre></div>
<div class="paragraph"><p>This returns the two paths starting from the first node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"Anders"},:KNOWS[0] {},Node[4]{name:"Bossman"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"Anders"},:BLOCKS[1] {},Node[5]{name:"Cesar"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3) match p = a--&gt;b return p</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-matching-on-a-bound-relationship">Matching on a bound relationship</h4>
<div class="paragraph"><p>When your pattern contains a bound relationship, and that relationship pattern doesn&#8217;t specify direction,
Cypher will try to match the relationship where the connected nodes switch sides.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START r=rel(0)
MATCH a-[r]-b
RETURN a,b</pre></div>
<div class="paragraph"><p>This returns the two connected nodes, once as the start node, and once as the end node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td><td align="left" valign="top">b</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start r=rel(0) match a-[r]-b return a,b</strong></span></p>
</div>
<div class="sect3">
<h4 id="match-match-with-or">Match with OR</h4>
<div class="paragraph"><p>Strictly speaking, you can&#8217;t do <code>OR</code> in your <code>MATCH</code>. It&#8217;s still possible to form a query that works a lot like <code>OR</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), b=node(2)
MATCH a-[?:KNOWS]-x-[?:KNOWS]-b
RETURN x</pre></div>
<div class="paragraph"><p>This query is saying: give me the nodes that are connected to <code>a</code>, or <code>b</code>, or both.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">3 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"Bossman"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Cesar"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"David"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3), b=node(2) match a-[?:KNOWS]-x-[?:KNOWS]-b return x</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-where">Where</h3>
<div class="paragraph"><p>Si vous nécessitez un filtrage à part du pattern de données que vous
cherchez, vous pouvez ajouter cela à l&#8217;aide de clauses dans la partie
<code>WHERE</code> de la requête.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-where-graph.svg" alt="cypher-where-graph.svg" />
</div>
<div class="title">Figure 14. Graph</div>
</div>
<div class="sect3">
<h4 id="where-boolean-operations">Boolean operations</h4>
<div class="paragraph"><p>You can use the expected boolean operators <code>AND</code> and <code>OR</code>, and also the boolean function <code>NOT()</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE (n.age &lt; 30 and n.name = "Tobias") or not(n.name = "Tobias")
RETURN n</pre></div>
<div class="paragraph"><p>This will return both nodes in the start clause.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where (n.age &lt; 30 and n.name = "Tobias") or not(n.name = "Tobias")  return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-filter-on-node-property">Filter on node property</h4>
<div class="paragraph"><p>To filter on a property, write your clause after the <code>WHERE</code> keyword. Filtering on relationship properties works just the same way.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.age &lt; 30
RETURN n</pre></div>
<div class="paragraph"><p>The "<code>Tobias</code>" node will be returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.age &lt; 30 return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-regular-expressions">Regular expressions</h4>
<div class="paragraph"><p>You can match on regular expressions by using <code>=~ "regexp"</code>, like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.name =~ 'Tob.*'
RETURN n</pre></div>
<div class="paragraph"><p>The "<code>Tobias</code>" node will be returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.name =~ 'Tob.*' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-escaping-in-regular-expressions">Escaping in regular expressions</h4>
<div class="paragraph"><p>If you need a forward slash inside of your regular expression, escape it. Remember that back slash needs to be escaped in string literals</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.name =~ 'Some\\/thing'
RETURN n</pre></div>
<div class="paragraph"><p>No nodes match this regular expression.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">0 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.name =~ 'Some\\/thing' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-case-insensitive-regular-expressions">Case insensitive regular expressions</h4>
<div class="paragraph"><p>By pre-pending a regular expression with <code>(?i)</code>, the whole expression becomes case insensitive.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.name =~ '(?i)ANDR.*'
RETURN n</pre></div>
<div class="paragraph"><p>The node with name "<code>Andres</code>" is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.name =~ '(?i)ANDR.*' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-filtering-on-relationship-type">Filtering on relationship type</h4>
<div class="paragraph"><p>You can put the exact relationship type in the <code>MATCH</code> pattern, but sometimes you want to be able to do more advanced filtering on the type. You can use the special property <code>TYPE</code> to compare the type with something else. In this example, the query does a regular expression comparison with the name of the relationship type.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r]-&gt;()
WHERE type(r) =~ 'K.*'
RETURN r</pre></div>
<div class="paragraph"><p>This returns relationships that has a type whose name starts with K.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[1] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[r]-&gt;() where type(r) =~ 'K.*' return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-property-exists">Property exists</h4>
<div class="paragraph"><p>To only include nodes/relationships that have a property, use the <code>HAS()</code> function and just write out the identifier and the property you expect it to have.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE has(n.belt)
RETURN n</pre></div>
<div class="paragraph"><p>The node named "<code>Andres</code>" is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where has(n.belt) return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-default-true-if-property-is-missing">Default true if property is missing</h4>
<div class="paragraph"><p>If you want to compare a property on a graph element, but only if it exists, use the nullable property syntax. You can use a question mark if you want missing property to return true, like:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.belt? = 'white'
RETURN n</pre></div>
<div class="paragraph"><p>This returns all nodes, even those without the belt property.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.belt? = 'white' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-default-false-if-property-is-missing">Default false if property is missing</h4>
<div class="paragraph"><p>When you need missing property to evaluate to false, use the exclamation mark.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 1)
WHERE n.belt! = 'white'
RETURN n</pre></div>
<div class="paragraph"><p>No nodes without the belt property are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 1) where n.belt! = 'white' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-filter-on-null-values">Filter on null values</h4>
<div class="paragraph"><p>Sometimes you might want to test if a value or an identifier is <code>null</code>. This is done just like SQL does it, with <code>IS NULL</code>. Also like SQL, the negative is <code>IS NOT NULL</code>, although <code>NOT(IS NULL x)</code> also works.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1), b=node(3, 2)
MATCH a&lt;-[r?]-b
WHERE r is null
RETURN b</pre></div>
<div class="paragraph"><p>Nodes that Tobias is not connected to are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">b</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Peter",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(1), b=node(3, 2) match a&lt;-[r?]-b where r is null return b</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-filter-on-patterns">Filter on patterns</h4>
<div class="paragraph"><p>Patterns are expressions in Cypher, expressions that return a collection of paths. Collection
expressions are also predicates&#8201;&#8212;&#8201;an empty collection represents <code>false</code>, and a non-empty represents <code>true</code>.</p></div>
<div class="paragraph"><p>So, patterns are not only expressions, they are also predicates. The only limitation to your pattern is that you must be
able to express it in a single path. You can not use commas between multiple paths like you do in <code>MATCH</code>. You can achieve
the same effect by combining multiple patterns with <code>AND</code>.</p></div>
<div class="paragraph"><p>Note that you can not introduce new identifiers here. Although it might look very similar to the <code>MATCH</code> patterns, the
<code>WHERE</code> clause is all about eliminating matched subgraphs. <code>MATCH a-[*]-&gt;b</code> is very different from <code>WHERE a-[*]-&gt;b</code>; the
first will produce a subgraph for every path it can find between <code>a</code> and <code>b</code>, and the latter will eliminate any matched
subgraphs where <code>a</code> and <code>b</code> do not have a directed relationship chain between them.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START tobias=node(1), others=node(3, 2)
WHERE tobias&lt;--others
RETURN others</pre></div>
<div class="paragraph"><p>Nodes that have an outgoing relationship to the "<code>Tobias</code>" node are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">others</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres",age:36,belt:"white"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start tobias=node(1), others=node(3, 2) where tobias&lt;--others return others</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-filter-on-patterns-using-not">Filter on patterns using NOT</h4>
<div class="paragraph"><p>The <code>NOT()</code> function can be used to exclude a pattern.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START persons=node(*), peter=node(2)
WHERE not(persons--&gt;peter)
RETURN persons</pre></div>
<div class="paragraph"><p>Nodes that do not have an outgoing relationship to the "<code>Peter</code>" node are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">persons</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Peter",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start persons=node(*), peter=node(2) where not(persons--&gt;peter) return persons</strong></span></p>
</div>
<div class="sect3">
<h4 id="where-in-operator">IN operator</h4>
<div class="paragraph"><p>To check if an element exists in a collection, you can use the <code>IN</code> operator.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3, 1, 2)
WHERE a.name IN ["Peter", "Tobias"]
RETURN a</pre></div>
<div class="paragraph"><p>This query shows how to check if a property exists in a literal collection.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Tobias",age:25}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Peter",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"belt":"white","name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(3, 1, 2) where a.name IN ["Peter", "Tobias"] return a</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-return">Return</h3>
<div class="paragraph"><p>Dans la partie <code>RETURN</code> de votre requête, vous définissez quelles parties du
pattern vous intéressent. Il peut s&#8217;agir de noeuds, relations ou propriétés
sur ceux-ci.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-return-graph.svg" alt="cypher-return-graph.svg" />
</div>
<div class="title">Figure 15. Graph</div>
</div>
<div class="sect3">
<h4 id="return-return-nodes">Return nodes</h4>
<div class="paragraph"><p>To return a node, list it in the <code>RETURN</code> statemenet.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2)
RETURN n</pre></div>
<div class="paragraph"><p>The example will return the node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(2) return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-return-relationships">Return relationships</h4>
<div class="paragraph"><p>To return a relationship, just include it in the <code>RETURN</code> list.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
MATCH (n)-[r:KNOWS]-&gt;(c)
RETURN r</pre></div>
<div class="paragraph"><p>The relationship is returned by the example.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(1) match (n)-[r:KNOWS]-&gt;(c) return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-return-property">Return property</h4>
<div class="paragraph"><p>To return a property, use the dot separator, like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN n.name</pre></div>
<div class="paragraph"><p>The value of the property <code>name</code> gets returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n.name</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"A"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(1) return n.name</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-return-all-elements">Return all elements</h4>
<div class="paragraph"><p>When you want to return all nodes, relationships and paths found in a query, you can use the <code>*</code> symbol.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
MATCH p=a-[r]-&gt;b
RETURN *</pre></div>
<div class="paragraph"><p>This returns the two nodes, the relationship and the path used in the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">b</td><td align="left" valign="top">a</td><td align="left" valign="top">r</td><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="4">2 rows
</th></tr><tr><th align="left" valign="top" colspan="4">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",happy:"Yes!",age:55}</code></p></td><td align="left" valign="top"><p><code class="literal">:KNOWS[0] {}</code></p></td><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"A",happy:"Yes!",age:55},:KNOWS[0] {},Node[2]{name:"B"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",happy:"Yes!",age:55}</code></p></td><td align="left" valign="top"><p><code class="literal">:BLOCKS[1] {}</code></p></td><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"A",happy:"Yes!",age:55},:BLOCKS[1] {},Node[2]{name:"B"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(1) match p=a-[r]-&gt;b return *</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-identifier-with-uncommon-characters">Identifier with uncommon characters</h4>
<div class="paragraph"><p>To introduce a placeholder that is made up of characters that are
      outside of the english alphabet, you can use the <code>`</code> to enclose the identifier, like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START `This isn't a common identifier`=node(1)
RETURN `This isn't a common identifier`.happy</pre></div>
<div class="paragraph"><p>The node indexed with name "A" is returned</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">This isn't a common identifier.happy</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Yes!"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start `This isn't a common identifier`=node(1)
 return `This isn't a common identifier`.happy</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-column-alias">Column alias</h4>
<div class="paragraph"><p>If the name of the column should be different from the expression used, you can rename it by using <code>AS</code> &lt;new name&gt;.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
RETURN a.age AS SomethingTotallyDifferent</pre></div>
<div class="paragraph"><p>Returns the age property of a node, but renames the column.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">SomethingTotallyDifferent</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">55</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(1) return a.age AS SomethingTotallyDifferent</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-optional-properties">Optional properties</h4>
<div class="paragraph"><p>If a property might or might not be there, you can select it optionally by adding a questionmark to the identifier,
like this:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1, 2)
RETURN n.age?</pre></div>
<div class="paragraph"><p>This example returns the age when the node has that property, or <code>null</code> if the property is not there.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n.age?</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">55</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(1, 2) return n.age?</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-other-expressions">Other expressions</h4>
<div class="paragraph"><p>Any expression can be used as a return iterm - literals, predicates, properties, functions, and everything else.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
RETURN a.age &gt; 30, "I'm a literal", length(a--&gt;())</pre></div>
<div class="paragraph"><p>Returns a predicate, a literal and function call with a pattern expression parameter.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.age &gt; 30</td><td align="left" valign="top">"I'm a literal"</td><td align="left" valign="top">length(a--&gt;())</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="3">1 row
</th></tr><tr><th align="left" valign="top" colspan="3">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">"I'm a literal"</code></p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(1) return a.age &gt; 30, "I'm a literal", length(a--&gt;())</strong></span></p>
</div>
<div class="sect3">
<h4 id="return-unique-results">Unique results</h4>
<div class="paragraph"><p><code>DISTINCT</code> retrieves only unique rows depending on the columns that have been selected to output.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
MATCH (a)--&gt;(b)
RETURN distinct b</pre></div>
<div class="paragraph"><p>The node named B is returned by the query, but only once.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">b</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":55,"happy":"Yes!","name":"A"}
(2) {"name":"B"}
(1)-[:KNOWS]-&gt;(2) {}
(1)-[:BLOCKS]-&gt;(2) {}
</span><span class="command"><strong>
 start a=node(1) match (a)--&gt;(b) return distinct b</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-aggregation">Agrégation</h3>
<div class="sect3">
<h4 id="aggregation-introduction">Introduction</h4>
<div class="paragraph"><p>To calculate aggregated data, Cypher offers aggregation, much like SQL&#8217;s <code>GROUP BY</code>.</p></div>
<div class="paragraph"><p>Aggregate functions take multiple input values and calculate an aggregated value from them. Examples are <code>AVG</code> that
calculate the average of multiple numeric values, or <code>MIN</code> that finds the smallest numeric value in a set of values.</p></div>
<div class="paragraph"><p>Aggregation can be done over all the matching sub graphs, or it can be further divided by introducing key values.
These are non-aggregate expressions, that are used to group the values going into the aggregate functions.</p></div>
<div class="paragraph"><p>So, if the return statement looks something like this:</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">RETURN n, count(*)</pre></div>
<div class="paragraph"><p>We have two return expressions&#8201;&#8212;&#8201;<code>n</code>, and <code>count(*)</code>. The first, <code>n</code>, is no aggregate function, and so it will be the
grouping key. The latter, <code>count(*)</code> is an aggregate expression. So the matching subgraphs will be divided into
different buckets, depending on the grouping key. The aggregate function will then run on these buckets, calculating
the aggregate values.</p></div>
<div class="paragraph"><p>If you want to use aggregations to sort your result set, the aggregation must be included in the <code>RETURN</code> to be used
in your <code>ORDER BY</code>.</p></div>
<div class="paragraph"><p>The last piece of the puzzle is the <code>DISTINCT</code> keyword. It is used to make all values unique before running them through
an aggregate function.</p></div>
<div class="paragraph"><p>An example might be helpful:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START me=node(1)
MATCH me--&gt;friend--&gt;friend_of_friend
RETURN count(distinct friend_of_friend), count(friend_of_friend)</pre></div>
<div class="paragraph"><p>In this example we are trying to find all our friends of friends, and count them. The first aggregate function, <code>count(distinct friend_of_friend)</code>, will only see a <code>friend_of_friend</code> once&#8201;&#8212;&#8201;<code>DISTINCT</code> removes the duplicates. The latter aggregate function, <code>count(friend_of_friend)</code>, might very well see the same <code>friend_of_friend</code> multiple times. Since there is no real data in this case, an empty result is returned. See the sections below for real data.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">count(distinct friend_of_friend)</td><td align="left" valign="top">count(friend_of_friend)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">0</code></p></td><td align="left" valign="top"><p><code class="literal">0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 START me=node(1) MATCH me--&gt;friend--&gt;friend_of_friend RETURN count(distinct friend_of_friend), count(friend_of_friend)</strong></span></p>
<div class="paragraph"><p>Les exemples suivants prennent comme base le graphe ci-dessous.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-aggregation-graph.svg" alt="cypher-aggregation-graph.svg" />
</div>
<div class="title">Figure 16. Graph</div>
</div>
</div>
<div class="sect3">
<h4 id="_count">COUNT</h4>
<div class="paragraph"><p><code>COUNT</code> est utilisé pour compter le nombre de lignes. <code>COUNT</code> peut être
utilisé de deux façons différentes-- &#8216;COUNT(*)` qui compte seulement le
nombre de lignes correspondantes et <code>COUNT(&lt;identifiant&gt;)</code> qui compte le
nombre d&#8217;entrées qui ont une valeur non-nulle pour l&#8217;+&lt;identifiant&gt;+.</p></div>
</div>
<div class="sect3">
<h4 id="aggregation-count-nodes">Count nodes</h4>
<div class="paragraph"><p>To count the number of nodes, for example the number of nodes connected to one node, you can use <code>count(*)</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2)
MATCH (n)--&gt;(x)
RETURN n, count(*)</pre></div>
<div class="paragraph"><p>This returns the start node and the count of related nodes.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td><td align="left" valign="top">count(*)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"A",property:13}</code></p></td><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2) match (n)--&gt;(x) return n, count(*)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-group-count-relationship-types">Group Count Relationship Types</h4>
<div class="paragraph"><p>To count the groups of relationship types, return the types and count them with <code>count(*)</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2)
MATCH (n)-[r]-&gt;()
RETURN type(r), count(*)</pre></div>
<div class="paragraph"><p>The relationship types and their group count is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">type(r)</td><td align="left" valign="top">count(*)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"KNOWS"</code></p></td><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2) match (n)-[r]-&gt;() return type(r), count(*)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-count-entities">Count entities</h4>
<div class="paragraph"><p>Instead of counting the number of results with <code>count(*)</code>, it might be more expressive to include the name of the identifier you care about.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2)
MATCH (n)--&gt;(x)
RETURN count(x)</pre></div>
<div class="paragraph"><p>The example query returns the number of connected nodes from the start node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">count(x)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2) match (n)--&gt;(x) return count(x)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-count-non-null-values">Count non-null values</h4>
<div class="paragraph"><p>You can count the non-<code>null</code> values by using <code>count(&lt;identifier&gt;)</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4,1)
RETURN count(n.property?)</pre></div>
<div class="paragraph"><p>The count of related nodes with the <code>property</code> property set is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">count(n.property?)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4,1) return count(n.property?)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-sum">SUM</h4>
<div class="paragraph"><p>The <code>SUM</code> aggregation function simply sums all the numeric values it encounters. Nulls are silently dropped. This is an example of how you can use <code>SUM</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN sum(n.property)</pre></div>
<div class="paragraph"><p>This returns the sum of all the values in the property <code>property</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">sum(n.property)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">90</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return sum(n.property)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-avg">AVG</h4>
<div class="paragraph"><p><code>AVG</code> calculates the average of a numeric column.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN avg(n.property)</pre></div>
<div class="paragraph"><p>The average of all the values in the property <code>property</code> is returned by the example query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">avg(n.property)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">30.0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return avg(n.property)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-percentile_disc">PERCENTILE_DISC</h4>
<div class="paragraph"><p><code>PERCENTILE_DISC</code> calculates the percentile of a given value over a group, with a percentile from 0.0 to 1.0. It uses a rounding method, returning the nearest value to the percentile. For interpolated values, see PERCENTILE_CONT.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN percentile_disc(n.property, 0.5)</pre></div>
<div class="paragraph"><p>The 50th percentile of the values in the property <code>property</code> is returned by the example query. In this case, 0.5 is the median, or 50th percentile.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">percentile_disc(n.property, 0.5)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">33</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return percentile_disc(n.property, 0.5)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-percentile_cont">PERCENTILE_CONT</h4>
<div class="paragraph"><p><code>PERCENTILE_CONT</code> calculates the percentile of a given value over a group, with a percentile from 0.0 to 1.0. It uses a linear interpolation method, calculating a weighted average between two values, if the desired percentile lies between them. For nearest values using a rounding method, see PERCENTILE_DISC.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN percentile_cont(n.property, 0.4)</pre></div>
<div class="paragraph"><p>The 40th percentile of the values in the property <code>property</code> is returned by the example query, calculated with a weighted average.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">percentile_cont(n.property, 0.4)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">29.0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return percentile_cont(n.property, 0.4)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-max">MAX</h4>
<div class="paragraph"><p><code>MAX</code> find the largets value in a numeric column.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN max(n.property)</pre></div>
<div class="paragraph"><p>The largest of all the values in the property <code>property</code> is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">max(n.property)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">44</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return max(n.property)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-min">MIN</h4>
<div class="paragraph"><p><code>MIN</code> takes a numeric property as input, and returns the smallest value in that column.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4)
RETURN min(n.property)</pre></div>
<div class="paragraph"><p>This returns the smallest of all the values in the property <code>property</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">min(n.property)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">13</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4) return min(n.property)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-collect">COLLECT</h4>
<div class="paragraph"><p><code>COLLECT</code> collects all the values into a list. It will ignore null values,</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(2,3,4,1)
RETURN collect(n.property?)</pre></div>
<div class="paragraph"><p>Returns a single row, with all the values collected.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">collect(n.property?)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[13,33,44]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(2,3,4,1) return collect(n.property?)</strong></span></p>
</div>
<div class="sect3">
<h4 id="aggregation-distinct">DISTINCT</h4>
<div class="paragraph"><p>All aggregation functions also take the <code>DISTINCT</code> modifier, which removes duplicates from the values.
So, to count the number of unique eye colors from nodes related to <code>a</code>, this query can be used:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
MATCH a--&gt;b
RETURN count(distinct b.eyes)</pre></div>
<div class="paragraph"><p>Returns the number of eye colors.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">count(distinct b.eyes)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"eyes":"brown","name":"D"}
(2) {"name":"A","property":13}
(3) {"eyes":"blue","name":"B","property":33}
(4) {"eyes":"blue","name":"C","property":44}
(2)-[:KNOWS]-&gt;(3) {}
(2)-[:KNOWS]-&gt;(4) {}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) match a--&gt;b return count(distinct b.eyes)</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-order">Order by</h3>
<div class="paragraph"><p>Pour trier la sortie, utilisez la clause <code>ORDER BY</code>. Notez que vous ne
pouvez pas trier sur les noeuds et relations mais seulement sur les
propriétés de ceux-ci.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-orderby-graph.svg" alt="cypher-orderby-graph.svg" />
</div>
<div class="title">Figure 17. Graph</div>
</div>
<div class="sect3">
<h4 id="order-by-order-nodes-by-property">Order nodes by property</h4>
<div class="paragraph"><p><code>ORDER BY</code> is used to sort the output.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3,1,2)
RETURN n
ORDER BY n.name</pre></div>
<div class="paragraph"><p>The nodes are returned, sorted by their name.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",age:34,length:170}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B",age:34}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C",age:32,length:185}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"length":170,"name":"A"}
(2) {"age":34,"name":"B"}
(3) {"age":32,"length":185,"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(2)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(3,1,2) return n order by n.name</strong></span></p>
</div>
<div class="sect3">
<h4 id="order-by-order-nodes-by-multiple-properties">Order nodes by multiple properties</h4>
<div class="paragraph"><p>You can order by multiple properties by stating each identifier in the <code>ORDER BY</code> clause. Cypher will sort the result by the first identifier listed, and for equals values, go to the next property in the <code>ORDER BY</code> clause, and so on.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3,1,2)
RETURN n
ORDER BY n.age, n.name</pre></div>
<div class="paragraph"><p>This returns the nodes, sorted first by their age, and then by their name.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C",age:32,length:185}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",age:34,length:170}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"length":170,"name":"A"}
(2) {"age":34,"name":"B"}
(3) {"age":32,"length":185,"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(2)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(3,1,2) return n order by n.age, n.name</strong></span></p>
</div>
<div class="sect3">
<h4 id="order-by-order-nodes-in-descending-order">Order nodes in descending order</h4>
<div class="paragraph"><p>By adding <code>DESC[ENDING]</code> after the identifier to sort on, the sort will be done in reverse order.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3,1,2)
RETURN n
ORDER BY n.name DESC</pre></div>
<div class="paragraph"><p>The example returns the nodes, sorted by their name reversely.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C",age:32,length:185}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B",age:34}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",age:34,length:170}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"length":170,"name":"A"}
(2) {"age":34,"name":"B"}
(3) {"age":32,"length":185,"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(2)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(3,1,2) return n order by n.name DESC</strong></span></p>
</div>
<div class="sect3">
<h4 id="order-by-ordering-null">Ordering null</h4>
<div class="paragraph"><p>When sorting the result set, <code>null</code> will always come at the end of the result set for ascending sorting, and first when doing descending sort.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3,1,2)
RETURN n.length?, n
ORDER BY n.length?</pre></div>
<div class="paragraph"><p>The nodes are returned sorted by the length property, with a node without that property last.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n.length?</td><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">3 rows
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">170</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"A",age:34,length:170}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">185</code></p></td><td align="left" valign="top"><p><code class="literal">Node[3]{name:"C",age:32,length:185}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td><td align="left" valign="top"><p><code class="literal">Node[2]{name:"B",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"length":170,"name":"A"}
(2) {"age":34,"name":"B"}
(3) {"age":32,"length":185,"name":"C"}
(1)-[:KNOWS]-&gt;(2) {}
(2)-[:KNOWS]-&gt;(3) {}
</span><span class="command"><strong>
 start n=node(3,1,2) return n.length?, n order by n.length?</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-limit">Limit</h3>
<div class="paragraph"><p><code>LIMIT</code> vous offre la possibilité de ne retourner qu&#8217;une partie du résultat
total.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-limit-graph.svg" alt="cypher-limit-graph.svg" />
</div>
<div class="title">Figure 18. Graph</div>
</div>
<div class="sect3">
<h4 id="limit-return-first-part">Return first part</h4>
<div class="paragraph"><p>To return a subset of the result, starting from the top, use this syntax:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 4, 5, 1, 2)
RETURN n
LIMIT 3</pre></div>
<div class="paragraph"><p>The top three items are returned by the example query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"A"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"B"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"C"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"D"}
(2) {"name":"E"}
(3) {"name":"A"}
(4) {"name":"B"}
(5) {"name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 4, 5, 1, 2) return n limit 3</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-skip">Skip</h3>
<div class="paragraph"><p><code>SKIP</code> vous offre la possibilité de ne retourner qu&#8217;une partie du résultat
total. En utilisant <code>SKIP</code>, le résultat sera tronqué par le haut. Veuillez
noter qu&#8217;il n&#8217;y a pas de garanties sur l&#8217;ordre du résultat sauf si vous
utilisez la clause <code>ORDER BY</code>.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-skip-graph.svg" alt="cypher-skip-graph.svg" />
</div>
<div class="title">Figure 19. Graph</div>
</div>
<div class="sect3">
<h4 id="skip-skip-first-three">Skip first three</h4>
<div class="paragraph"><p>To return a subset of the result, starting from the fourth result, use the following syntax:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 4, 5, 1, 2)
RETURN n
ORDER BY n.name
SKIP 3</pre></div>
<div class="paragraph"><p>The first three nodes are skipped, and only the last two are returned in the result.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"D"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"E"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"D"}
(2) {"name":"E"}
(3) {"name":"A"}
(4) {"name":"B"}
(5) {"name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 4, 5, 1, 2) return n order by n.name skip 3</strong></span></p>
</div>
<div class="sect3">
<h4 id="skip-return-middle-two">Return middle two</h4>
<div class="paragraph"><p>To return a subset of the result, starting from somewhere in the middle, use this syntax:</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3, 4, 5, 1, 2)
RETURN n
ORDER BY n.name
SKIP 1
LIMIT 2</pre></div>
<div class="paragraph"><p>Two nodes from the middle are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"B"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"C"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"D"}
(2) {"name":"E"}
(3) {"name":"A"}
(4) {"name":"B"}
(5) {"name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3, 4, 5, 1, 2) return n order by n.name skip 1 limit 2</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-with">With</h3>
<div class="paragraph"><p>La possibilité de chaîner des requêtes entre elles vous permet de créer des
constructions puissantes. Dans Cypher, la clause <code>WITH</code> est utilisée pour
faire passer le résultat d&#8217;une requête dans la suivante.</p></div>
<div class="paragraph"><p><code>WITH</code> est également utilisé pour séparer la lecture et la mise à jour du
graphe. Chaque sous-requête d&#8217;une requête doit être ou lecture seule ou
écriture seule.</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-with-graph.svg" alt="cypher-with-graph.svg" />
</div>
<div class="title">Figure 20. Graph</div>
</div>
<div class="sect3">
<h4 id="with-filter-on-aggregate-function-results">Filter on aggregate function results</h4>
<div class="paragraph"><p>Aggregated results have to pass through a <code>WITH</code> clause to be able to filter on.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START david=node(1)
MATCH david--otherPerson--&gt;()
WITH otherPerson, count(*) as foaf
WHERE foaf &gt; 1
RETURN otherPerson</pre></div>
<div class="paragraph"><p>The person connected to David with the at least more than one outgoing relationship will be returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">otherPerson</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Anders"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start david=node(1) match david--otherPerson--&gt;() with otherPerson, count(*) as foaf where foaf &gt; 1 return otherPerson</strong></span></p>
</div>
<div class="sect3">
<h4 id="with-sort-results-before-using-collect-on-them">Sort results before using collect on them</h4>
<div class="paragraph"><p>You can sort your results before passing them to collect, thus sorting the resulting collection.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(*)
WITH n
ORDER BY n.name desc
LIMIT 3
RETURN collect(n.name)</pre></div>
<div class="paragraph"><p>A list of the names of people in reverse order, limited to 3, in a collection.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">collect(n.name)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">["Emil","David","Cesar"]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(*) with n order by n.name desc limit 3 return collect(n.name)</strong></span></p>
</div>
<div class="sect3">
<h4 id="with-limit-branching-of-your-path-search">Limit branching of your path search</h4>
<div class="paragraph"><p>You can match paths, limit to a certain number, and then match again using those paths as a base As well as any number of similar limited searches.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH n--m
WITH m
ORDER BY m.name desc
LIMIT 1
MATCH m--o
RETURN o.name</pre></div>
<div class="paragraph"><p>Starting at Anders, find all matching nodes, order by name descending and get the top result, then find all the nodes connected to that top result, and return their names.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">o.name</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Anders"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Bossman"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n=node(3) match n--m with m order by m.name desc limit 1 match m--o return o.name</strong></span></p>
</div>
<div class="sect3">
<h4 id="with-alternative-syntax-of-with">Alternative syntax of WITH</h4>
<div class="paragraph"><p>If you prefer a more visual way of writing your query, you can use equal-signs as delimiters before and after the column list. Use at least three before the column list, and at least three after.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START david=node(1)
MATCH david--otherPerson--&gt;()
========== otherPerson, count(*) as foaf ==========
SET otherPerson.connection_count = foaf</pre></div>
<div class="paragraph"><p>For persons connected to David, the <code>connection_count</code> property is set to their number of outgoing relationships.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Properties set: 2
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"David"}
(2) {"name":"Emil"}
(3) {"name":"Anders"}
(4) {"name":"Bossman"}
(5) {"name":"Cesar"}
(1)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:BLOCKS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(2) {}
(4)-[:BLOCKS]-&gt;(1) {}
(5)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>

 start david=node(1) match david--otherPerson--&gt;()
 ========== otherPerson, count(*) as foaf ==========
 set otherPerson.connection_count = foaf</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-create">Create</h3>
<div class="paragraph"><p>La création d'éléments de graphe&#8201;&#8212;&#8201;noeuds et relations, est effectuée avec
<code>CREATE</code>.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">Dans la clause <code>CREATE</code>, les patterns sont beaucoup utilisés. Lisez
<a href="#introduction-pattern">[introduction-pattern]</a> pour une introduction.</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="create-create-single-node">Create single node</h4>
<div class="paragraph"><p>Creating a single node is done by issuing the following query.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">CREATE n</pre></div>
<div class="paragraph"><p>Nothing is returned from this query, except the count of affected nodes.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(0)
</span><span class="command"><strong>create n</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-create-single-node-and-set-properties">Create single node and set properties</h4>
<div class="paragraph"><p>The values for the properties can be any scalar expressions.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">CREATE n = {name : 'Andres', title : 'Developer'}</pre></div>
<div class="paragraph"><p>Nothing is returned from this query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 2
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(0)
</span><span class="command"><strong>create n = {name : 'Andres', title : 'Developer'}</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-return-created-node">Return created node</h4>
<div class="paragraph"><p>Creating a single node is done by issuing the following query.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">CREATE (a {name : 'Andres'})
RETURN a</pre></div>
<div class="paragraph"><p>The newly created node is returned. This query uses the alternative syntax for single node creation.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Andres"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(0)
</span><span class="command"><strong>create (a {name : 'Andres'}) return a</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-create-a-relationship-between-two-nodes">Create a relationship between two nodes</h4>
<div class="paragraph"><p>To create a relationship between two nodes, we first get the two nodes. Once the nodes are loaded, we simply create a relationship between them.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1), b=node(2)
CREATE a-[r:RELTYPE]-&gt;b
RETURN r</pre></div>
<div class="paragraph"><p>The created relationship is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">3 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:RELTYPE[1] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {}
(2) {}
</span><span class="command"><strong>
 start a=node(1), b=node(2) create a-[r:RELTYPE]-&gt;b return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-create-a-relationship-and-set-properties">Create a relationship and set properties</h4>
<div class="paragraph"><p>Setting properties on relationships is done in a similar manner to how it&#8217;s done when creating nodes. Note that the values can be any expression.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1), b=node(2)
CREATE a-[r:RELTYPE {name : a.name + '&lt;-&gt;' + b.name }]-&gt;b
RETURN r</pre></div>
<div class="paragraph"><p>The newly created relationship is returned by the example query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:RELTYPE[1] {name:"Andres&lt;-&gt;Michael"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"Andres"}
(2) {"name":"Michael"}
</span><span class="command"><strong>
 start a=node(1), b=node(2) create a-[r:RELTYPE {name : a.name + '&lt;-&gt;' + b.name }]-&gt;b return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-create-a-full-path">Create a full path</h4>
<div class="paragraph"><p>When you use <code>CREATE</code> and a pattern, all parts of the pattern that are not already in scope at this time
will be created.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">CREATE p = (andres {name:'Andres'})-[:WORKS_AT]-&gt;neo&lt;-[:WORKS_AT]-(michael {name:'Michael'})
RETURN p</pre></div>
<div class="paragraph"><p>This query creates three nodes and two relationships in one go, assigns it to a path identifier, and returns it.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 3
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 2
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 2
</th></tr><tr><th align="left" valign="top" colspan="1">4 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[4]{name:"Andres"},:WORKS_AT[2] {},Node[5]{},:WORKS_AT[3] {},Node[6]{name:"Michael"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(0)
</span><span class="command"><strong>create p = (andres {name:'Andres'})-[:WORKS_AT]-&gt;neo&lt;-[:WORKS_AT]-(michael {name:'Michael'}) return p</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-create-single-node-from-map">Création d&#8217;un simple noeud depuis une map</h4>
<div class="paragraph"><p>Vous pouvez également créer une entité de graphe depuis une
<code>Map&lt;String,Object&gt;</code> map. Toutes les paires clé/valeur dans la map seront
affectées comme propriétés sur le noeud ou la relation créé.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">create ({props})</pre></div>
<div class="paragraph"><p>Cette requête peut être utilisée de la façon suivante:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> props = new HashMap<String, Object>();
props.put( "name", "Andres" );
props.put( "position", "Developer" );

Map<String, Object> params = new HashMap<String, Object>();
params.put( "props", props );
engine.execute( "create ({props})", params );</pre>
</div></div>
</div>
<div class="sect3">
<h4 id="create-create-multiple-nodes-from-map">Création de noeuds multiples depuis des maps</h4>
<div class="paragraph"><p>En fournissant une itération de maps (<code>Iterable&lt;Map&lt;String,Object&gt;&gt;</code>),
Cypher créera un noeud pour chaque map dans l&#8217;itération. Quand vous faites
cela, vous ne pouvez créer rien d&#8217;autre dans le même déclaratif create.</p></div>
<div class="listingblock">
<div class="title">Requête</div>
<pre class="programlisting brush: cypher">create (n {props}) return n</pre></div>
<div class="paragraph"><p>Cette requête peut être utilisée de la façon suivante:</p></div>
<div class="listingblock"><div class="content">
<pre class="programlisting brush: java">Map<String, Object> n1 = new HashMap<String, Object>();
n1.put( "name", "Andres" );
n1.put( "position", "Developer" );

Map<String, Object> n2 = new HashMap<String, Object>();
n2.put( "name", "Michael" );
n2.put( "position", "Developer" );

Map<String, Object> params = new HashMap<String, Object>();
List<Map<String, Object>> maps = Arrays.asList( n1, n2 );
params.put( "props", maps );
engine.execute( "create (n {props}) return n", params );</pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="query-create-unique">Create Unique</h3>
<div class="paragraph"><p><code>CREATE UNIQUE</code> is in the middle of <code>MATCH</code> and <code>CREATE</code>&#8201;&#8212;&#8201;it will match
what it can, and create what is missing.  <code>CREATE UNIQUE</code> will always make
the least change possible to the graph&#8201;&#8212;&#8201;if it can use parts of the
existing graph, it will.</p></div>
<div class="paragraph"><p>Another difference to <code>MATCH</code> is that <code>CREATE UNIQUE</code> assumes the pattern to
be unique. If multiple matching subgraphs are found an exception will be
thrown.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">In the <code>CREATE UNIQUE</code> clause, patterns are used a lot.  Read
<a href="#introduction-pattern">[introduction-pattern]</a> for an introduction.</td>
</tr></table>
</div>
<div class="paragraph"><p>The examples start out with the following data set:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-createunique-graph.svg" alt="cypher-createunique-graph.svg" />
</div>
</div>
<div class="sect3">
<h4 id="create-unique-create-relationship-if-it-is-missing">Create relationship if it is missing</h4>
<div class="paragraph"><p><code>CREATE UNIQUE</code> is used to describe the pattern that should be found or created.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START left=node(1), right=node(3,4)
CREATE UNIQUE left-[r:KNOWS]-&gt;right
RETURN r</pre></div>
<div class="paragraph"><p>The left node is matched agains the two right nodes. One relationship already exists and can be matched, and the other relationship is created before it is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[5] {}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:KNOWS[3] {}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"A"}
(2) {"name":"root"}
(3) {"name":"B"}
(4) {"name":"C"}
(1)-[:KNOWS]-&gt;(4) {}
(2)-[:X]-&gt;(1) {}
(2)-[:X]-&gt;(3) {}
(2)-[:X]-&gt;(4) {}
</span><span class="command"><strong>
 start left=node(1), right=node(3,4) create unique left-[r:KNOWS]-&gt;right return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-unique-create-node-if-missing">Create node if missing</h4>
<div class="paragraph"><p>If the pattern described needs a node, and it can&#8217;t be matched, a new node will be created.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START root=node(2)
CREATE UNIQUE root-[:LOVES]-someone
RETURN someone</pre></div>
<div class="paragraph"><p>The root node doesn&#8217;t have any <code>LOVES</code> relationships, and so a node is created, and also a relationship to that node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">someone</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[6]{}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"A"}
(2) {"name":"root"}
(3) {"name":"B"}
(4) {"name":"C"}
(1)-[:KNOWS]-&gt;(4) {}
(2)-[:X]-&gt;(1) {}
(2)-[:X]-&gt;(3) {}
(2)-[:X]-&gt;(4) {}
</span><span class="command"><strong>
 start root=node(2) create unique root-[:LOVES]-someone return someone</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-unique-create-nodes-with-values">Create nodes with values</h4>
<div class="paragraph"><p>The pattern described can also contain values on the node. These are given using the following syntax: <code>prop : &lt;expression&gt;</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START root=node(2)
CREATE UNIQUE root-[:X]-(leaf {name:'D'} )
RETURN leaf</pre></div>
<div class="paragraph"><p>No node connected with the root node has the name <code>D</code>, and so a new node is created to match the pattern.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">leaf</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">3 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"D"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"A"}
(2) {"name":"root"}
(3) {"name":"B"}
(4) {"name":"C"}
(1)-[:KNOWS]-&gt;(4) {}
(2)-[:X]-&gt;(1) {}
(2)-[:X]-&gt;(3) {}
(2)-[:X]-&gt;(4) {}
</span><span class="command"><strong>
 start root=node(2) create unique root-[:X]-(leaf {name:'D'} ) return leaf</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-unique-create-relationship-with-values">Create relationship with values</h4>
<div class="paragraph"><p>Relationships to be created can also be matched on values.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START root=node(2)
CREATE UNIQUE root-[r:X {since:'forever'}]-()
RETURN r</pre></div>
<div class="paragraph"><p>In this example, we want the relationship to have a value, and since no such relationship can be found, a new node and relationship are created. Note that since we are not interested in the created node, we don&#8217;t name it.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:X[5] {since:"forever"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"A"}
(2) {"name":"root"}
(3) {"name":"B"}
(4) {"name":"C"}
(1)-[:KNOWS]-&gt;(4) {}
(2)-[:X]-&gt;(1) {}
(2)-[:X]-&gt;(3) {}
(2)-[:X]-&gt;(4) {}
</span><span class="command"><strong>
 start root=node(2) create unique root-[r:X {since:'forever'}]-() return r</strong></span></p>
</div>
<div class="sect3">
<h4 id="create-unique-describe-complex-pattern">Describe complex pattern</h4>
<div class="paragraph"><p>The pattern described by <code>CREATE UNIQUE</code> can be separated by commas, just like in <code>MATCH</code> and <code>CREATE</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START root=node(2)
CREATE UNIQUE root-[:FOO]-&gt;x, root-[:BAR]-&gt;x
RETURN x</pre></div>
<div class="paragraph"><p>This example pattern uses two paths, separated by a comma.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">x</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Nodes created: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships created: 2
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[6]{}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"A"}
(2) {"name":"root"}
(3) {"name":"B"}
(4) {"name":"C"}
(1)-[:KNOWS]-&gt;(4) {}
(2)-[:X]-&gt;(1) {}
(2)-[:X]-&gt;(3) {}
(2)-[:X]-&gt;(4) {}
</span><span class="command"><strong>
 start root=node(2) create unique root-[:FOO]-&gt;x, root-[:BAR]-&gt;x return x</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-set">Set</h3>
<div class="paragraph"><p>Updating properties on nodes and relationships is done with the <code>SET</code>
clause.  <code>SET</code> can also be used with maps from parameters.</p></div>
<div class="paragraph"><p>The examples use this graph as a starting point:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-set-graph.svg" alt="cypher-set-graph.svg" />
</div>
</div>
<div class="sect3">
<h4 id="set-set-a-property">Set a property</h4>
<div class="paragraph"><p>To set a property on a node or relationship, use <code>SET</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n = node(2)
SET n.surname = 'Taylor'
RETURN n</pre></div>
<div class="paragraph"><p>The newly changed node is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Andres",age:36,awesome:true,surname:"Taylor"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"name":"Peter"}
(2) {"age":36,"awesome":true,"name":"Andres"}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n = node(2) set n.surname = 'Taylor' return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="set-remove-a-property">Remove a property</h4>
<div class="paragraph"><p>Normally you remove a property by using delete, but it&#8217;s sometimes handy to do
it using the <code>SET</code> command. One example is if the property comes from a parameter.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n = node(2)
SET n.name = null
RETURN n</pre></div>
<div class="paragraph"><p>The node is returned by the query, and the name property is now missing.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">n</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{age:36,awesome:true}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"name":"Peter"}
(2) {"age":36,"awesome":true,"name":"Andres"}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n = node(2) set n.name = null return n</strong></span></p>
</div>
<div class="sect3">
<h4 id="set-copying-properties-between-nodes-and-relationships">Copying properties between nodes and relationships</h4>
<div class="paragraph"><p>You can also use SET to copy all properties from one graph element to another. Remember that doing this
will remove all other properties on the receiving graph element.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START at = node(2), pn = node(1)
SET at = pn
RETURN at, pn</pre></div>
<div class="paragraph"><p>The Andres node has had all it&#8217;s properties replaced by the properties in the Peter node.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">at</td><td align="left" valign="top">pn</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">Properties set: 3
</th></tr><tr><th align="left" valign="top" colspan="2">5 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Peter",age:34}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Peter",age:34}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":34,"name":"Peter"}
(2) {"age":36,"awesome":true,"name":"Andres"}
(2)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start at = node(2), pn = node(1) set at = pn return at, pn</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-delete">Delete</h3>
<div class="paragraph"><p>Removing graph elements&#8201;&#8212;&#8201;nodes, relationships and properties, is done with
<code>DELETE</code>.</p></div>
<div class="paragraph"><p>The examples start out with the following database:</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-delete-graph.svg" alt="cypher-delete-graph.svg" />
</div>
</div>
<div class="sect3">
<h4 id="delete-delete-single-node">Delete single node</h4>
<div class="paragraph"><p>To remove a node from the graph, you can delete it with the <code>DELETE</code> clause.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n = node(4)
DELETE n</pre></div>
<div class="paragraph"><p>Nothing is returned from this query, except the count of affected nodes.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Nodes deleted: 1
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"name":"Andres"}
(4) {}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n = node(4) delete n</strong></span></p>
</div>
<div class="sect3">
<h4 id="delete-remove-a-node-and-connected-relationships">Remove a node and connected relationships</h4>
<div class="paragraph"><p>If you are trying to remove a node with relationships on it, you have to remove these as well.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n = node(3)
MATCH n-[r]-()
DELETE n, r</pre></div>
<div class="paragraph"><p>Nothing is returned from this query, except the count of affected nodes.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Nodes deleted: 1
</th></tr><tr><th align="left" valign="top" colspan="1">Relationships deleted: 2
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start n = node(3) match n-[r]-() delete n, r</strong></span></p>
</div>
<div class="sect3">
<h4 id="delete-remove-a-property">Remove a property</h4>
<div class="paragraph"><p>Neo4j doesn&#8217;t allow storing <code>null</code> in properties. Instead, if no value exists, the property is just not there. So, to remove a property value on a node or a relationship, is also done with <code>DELETE</code>.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START andres = node(3)
DELETE andres.age
RETURN andres</pre></div>
<div class="paragraph"><p>The node is returned, and no property <code>age</code> exists on it.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">andres</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">Properties set: 1
</th></tr><tr><th align="left" valign="top" colspan="1">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"Andres"}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":25,"name":"Tobias"}
(2) {"age":34,"name":"Peter"}
(3) {"age":36,"name":"Andres"}
(3)-[:KNOWS]-&gt;(1) {}
(3)-[:KNOWS]-&gt;(2) {}
</span><span class="command"><strong>
 start andres = node(3) delete andres.age return andres</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-foreach">Foreach</h3>
<div class="paragraph"><p>Collections and paths are key concepts in Cypher. To use them for updating
data, you can use the <code>FOREACH</code> construct.  It allows you to do updating
commands on elements in a collection&#8201;&#8212;&#8201;a path, or a collection created by
aggregation.</p></div>
<div class="paragraph"><p>The identifier context inside of the foreach parenthesis is separate from
the one outside it, i.e. if you <code>CREATE</code> a node identifier inside of a
<code>FOREACH</code>, you will not be able to use it outside of the foreach statement,
unless you match to find it.</p></div>
<div class="paragraph"><p>Inside of the <code>FOREACH</code> parentheses, you can do any updating commands&#8201;&#8212;&#8201;<code>CREATE</code>, <code>CREATE UNIQUE</code>, <code>DELETE</code>, and <code>FOREACH</code>.</p></div>
<div class="sect3">
<h4 id="foreach-mark-all-nodes-along-a-path">Mark all nodes along a path</h4>
<div class="paragraph"><p>This query will set the property <code>marked</code> to true on all nodes along a path.</p></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START begin = node(2), end = node(1)
MATCH p = begin -[*]-&gt; end foreach(n in nodes(p) :
SET n.marked = true)</pre></div>
<div class="paragraph"><p>Nothing is returned from this query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><tfoot><tr><th align="left" valign="top" colspan="1">Properties set: 4
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td class="emptyresult" align="left" valign="top" colspan="1"><p><code class="literal">(empty result)</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"name":"D"}
(2) {"name":"A"}
(3) {"name":"B"}
(4) {"name":"C"}
(2)-[:KNOWS]-&gt;(3) {}
(3)-[:KNOWS]-&gt;(4) {}
(4)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start begin = node(2), end = node(1) match p = begin -[*]-&gt; end foreach(n in nodes(p) : set n.marked = true)</strong></span></p>
</div>
</div>
<div class="sect2">
<h3 id="query-function">Functions</h3>
<div class="paragraph"><p>Most functions in Cypher will return <code>null</code> if the input parameter is
<code>null</code>.</p></div>
<div class="paragraph"><p>Here is a list of the functions in Cypher, seperated into three different
sections: Predicates, Scalar functions and Aggregated functions</p></div>
<div class="imageblock dot">
<div class="content">
<img src="images/cypher-functions-graph.svg" alt="cypher-functions-graph.svg" />
</div>
<div class="title">Figure 21. Graph</div>
</div>
<div class="sect3">
<h4 id="_predicates">Predicates</h4>
<div class="paragraph"><p>Predicates are boolean functions that return true or false for a given set
of input.  They are most commonly used to filter out subgraphs in the
<code>WHERE</code> part of a query.</p></div>
<div class="paragraph"><p>See also <a href="#query-operators-comparison">[query-operators-comparison]</a>.</p></div>
<div class="sect4">
<h5 id="functions-all">ALL</h5>
<div class="paragraph"><p>Tests whether a predicate holds for all element of this collection collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>ALL(identifier in collection WHERE predicate)</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> This is the identifier that can be used from the predicate.
</p>
</li>
<li>
<p>
<em>predicate:</em> A predicate that is tested against all items in the collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), b=node(1)
MATCH p=a-[*1..3]-&gt;b
WHERE all(x in nodes(p)
WHERE x.age &gt; 30)
RETURN p</pre></div>
<div class="paragraph"><p>All nodes in the returned paths will have an <code>age</code> property of at least 30.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"A",age:38,eyes:"brown"},:KNOWS[1] {},Node[5]{name:"C",age:53,eyes:"green"},:KNOWS[3] {},Node[1]{name:"D",age:54,eyes:"brown"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), b=node(1) match p=a-[*1..3]-&gt;b where all(x in nodes(p) WHERE x.age &gt; 30) return p</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-any">ANY</h5>
<div class="paragraph"><p>Tests whether a predicate holds for at least one element in the collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>ANY(identifier in collection WHERE predicate)</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> This is the identifier that can be used from the predicate.
</p>
</li>
<li>
<p>
<em>predicate:</em> A predicate that is tested against all items in the collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
WHERE any(x in a.array
WHERE x = "one")
RETURN a</pre></div>
<div class="paragraph"><p>All nodes in the returned paths has at least one <code>one</code> value set in the array property named <code>array</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"E",age:41,eyes:"blue",array:["one","two","three"]}</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) where any(x in a.array WHERE x = "one") return a</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-none">NONE</h5>
<div class="paragraph"><p>Returns true if the predicate holds for no element in the collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>NONE(identifier in collection WHERE predicate)</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> This is the identifier that can be used from the predicate.
</p>
</li>
<li>
<p>
<em>predicate:</em> A predicate that is tested against all items in the collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH p=n-[*1..3]-&gt;b
WHERE NONE(x in nodes(p)
WHERE x.age = 25)
RETURN p</pre></div>
<div class="paragraph"><p>No nodes in the returned paths has a <code>age</code> property set to <code>25</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">2 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"A",age:38,eyes:"brown"},:KNOWS[1] {},Node[5]{name:"C",age:53,eyes:"green"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"A",age:38,eyes:"brown"},:KNOWS[1] {},Node[5]{name:"C",age:53,eyes:"green"},:KNOWS[3] {},Node[1]{name:"D",age:54,eyes:"brown"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(3) match p=n-[*1..3]-&gt;b where NONE(x in nodes(p) WHERE x.age = 25) return p</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-single">SINGLE</h5>
<div class="paragraph"><p>Returns true if the predicate holds for exactly one of the elements in the collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>SINGLE(identifier in collection WHERE predicate)</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> This is the identifier that can be used from the predicate.
</p>
</li>
<li>
<p>
<em>predicate:</em> A predicate that is tested against all items in the collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH p=n--&gt;b
WHERE SINGLE(var in nodes(p)
WHERE var.eyes = "blue")
RETURN p</pre></div>
<div class="paragraph"><p>Exactly one node in every returned path will have the <code>eyes</code> property set to <code>"blue"</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">p</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"A",age:38,eyes:"brown"},:KNOWS[0] {},Node[4]{name:"B",age:25,eyes:"blue"}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(3) match p=n--&gt;b where SINGLE(var in nodes(p) WHERE var.eyes = "blue") return p</strong></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_scalar_functions">Scalar functions</h4>
<div class="paragraph"><p>Scalar functions return a single value.</p></div>
<div class="sect4">
<h5 id="functions-length">LENGTH</h5>
<div class="paragraph"><p>To return or filter on the length of a collection, use the <code>LENGTH()</code> function.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>LENGTH( collection )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
MATCH p=a--&gt;b--&gt;c
RETURN length(p)</pre></div>
<div class="paragraph"><p>The length of the path <code>p</code> is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">length(p)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">2</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3) match p=a--&gt;b--&gt;c return length(p)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-type">TYPE</h5>
<div class="paragraph"><p>Returns a string representation of the relationship type.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>TYPE( relationship )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>relationship:</em> A relationship.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(3)
MATCH (n)-[r]-&gt;()
RETURN type(r)</pre></div>
<div class="paragraph"><p>The relationship type of <code>r</code> is returned by the query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">type(r)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"KNOWS"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"KNOWS"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(3) match (n)-[r]-&gt;() return type(r)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-id">ID</h5>
<div class="paragraph"><p>Returns the id of the relationship or node.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>ID( property-container )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>property-container:</em> A node or a relationship.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3, 4, 5)
RETURN ID(a)</pre></div>
<div class="paragraph"><p>This returns the node id for three nodes.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">ID(a)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">3 rows
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">4</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">5</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3, 4, 5) return ID(a)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-coalesce">COALESCE</h5>
<div class="paragraph"><p>Returns the first non-<code>null</code> value in the list of expressions passed to it.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>COALESCE( expression [, expression]* )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> The expression that might return null.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3)
RETURN coalesce(a.hairColour?, a.eyes?)</pre></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">coalesce(a.hairColour?, a.eyes?)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"brown"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3) return coalesce(a.hairColour?, a.eyes?)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-head">HEAD</h5>
<div class="paragraph"><p><code>HEAD</code> returns the first element in a collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>HEAD( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> This expression should return a collection of some kind.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
RETURN a.array, head(a.array)</pre></div>
<div class="paragraph"><p>The first node in the path is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.array</td><td align="left" valign="top">head(a.array)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">["one","two","three"]</code></p></td><td align="left" valign="top"><p><code class="literal">"one"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) return a.array, head(a.array)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-last">LAST</h5>
<div class="paragraph"><p><code>LAST</code> returns the last element in a collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>LAST( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> This expression should return a collection of some kind.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
RETURN a.array, last(a.array)</pre></div>
<div class="paragraph"><p>The last node in the path is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.array</td><td align="left" valign="top">last(a.array)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">["one","two","three"]</code></p></td><td align="left" valign="top"><p><code class="literal">"three"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) return a.array, last(a.array)</strong></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_collection_functions">Collection functions</h4>
<div class="paragraph"><p>Collection functions return collections of things&#8201;&#8212;&#8201;nodes in a path, and so
on.</p></div>
<div class="paragraph"><p>See also <a href="#query-operators-collection">[query-operators-collection]</a>.</p></div>
<div class="sect4">
<h5 id="functions-nodes">NODES</h5>
<div class="paragraph"><p>Returns all nodes in a path.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>NODES( path )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>path:</em> A path.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), c=node(2)
MATCH p=a--&gt;b--&gt;c
RETURN NODES(p)</pre></div>
<div class="paragraph"><p>All the nodes in the path <code>p</code> are returned by the example query.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NODES(p)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[3]{name:"A",age:38,eyes:"brown"},Node[4]{name:"B",age:25,eyes:"blue"},Node[2]{name:"E",age:41,eyes:"blue",array:["one","two","three"]}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), c=node(2) match p=a--&gt;b--&gt;c return NODES(p)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-relationships">RELATIONSHIPS</h5>
<div class="paragraph"><p>Returns all relationships in a path.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>RELATIONSHIPS( path )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>path:</em> A path.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), c=node(2)
MATCH p=a--&gt;b--&gt;c
RETURN RELATIONSHIPS(p)</pre></div>
<div class="paragraph"><p>All the relationships in the path <code>p</code> are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">RELATIONSHIPS(p)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[:KNOWS[0] {},:MARRIED[4] {}]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), c=node(2) match p=a--&gt;b--&gt;c return RELATIONSHIPS(p)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-extract">EXTRACT</h5>
<div class="paragraph"><p>To return a single property, or the value of a function from a collection of nodes or relationships,
 you can use <code>EXTRACT</code>. It will go through a collection, run an expression on every element, and return the results
 in an collection with these values. It works like the <code>map</code> method in functional languages such as Lisp and Scala.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>EXTRACT( identifier in collection : expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> The closure will have an identifier introduced in it&#8217;s context. Here you decide which identifier to use.
</p>
</li>
<li>
<p>
<em>expression:</em> This expression will run once per value in the collection, and produces the result collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), b=node(4), c=node(1)
MATCH p=a--&gt;b--&gt;c
RETURN extract(n in nodes(p) : n.age)</pre></div>
<div class="paragraph"><p>The age property of all nodes in the path are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">extract(n in nodes(p) : n.age)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[38,25,54]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), b=node(4), c=node(1) match p=a--&gt;b--&gt;c return extract(n in nodes(p) : n.age)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-filter">FILTER</h5>
<div class="paragraph"><p><code>FILTER</code> returns all the elements in a collection that comply to a predicate.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>FILTER(identifier in collection : predicate)</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> This is the identifier that can be used from the predicate.
</p>
</li>
<li>
<p>
<em>predicate:</em> A predicate that is tested against all items in the collection.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
RETURN a.array, filter(x in a.array : length(x) = 3)</pre></div>
<div class="paragraph"><p>This returns the property named <code>array</code> and a list of values in it, which have the length <code>3</code>.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.array</td><td align="left" valign="top">filter(x in a.array : length(x) = 3)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">["one","two","three"]</code></p></td><td align="left" valign="top"><p><code class="literal">["one","two"]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) return a.array, filter(x in a.array : length(x) = 3)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-tail">TAIL</h5>
<div class="paragraph"><p><code>TAIL</code> returns all but the first element in a collection.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>TAIL( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> This expression should return a collection of some kind.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(2)
RETURN a.array, tail(a.array)</pre></div>
<div class="paragraph"><p>This returns the property named <code>array</code> and all elements of that property except the first one.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.array</td><td align="left" valign="top">tail(a.array)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">["one","two","three"]</code></p></td><td align="left" valign="top"><p><code class="literal">["two","three"]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(2) return a.array, tail(a.array)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-range">RANGE</h5>
<div class="paragraph"><p>Returns numerical values in a range with a non-zero step value step. Range is inclusive in both ends.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>RANGE( start, end [, step] )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>start:</em> A numerical expression.
</p>
</li>
<li>
<p>
<em>end:</em> A numerical expression.
</p>
</li>
<li>
<p>
<em>step:</em> A numerical expression.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN range(0,10), range(2,18,3)</pre></div>
<div class="paragraph"><p>Two lists of numbers are returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">range(0,10)</td><td align="left" valign="top">range(2,18,3)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[0,1,2,3,4,5,6,7,8,9,10]</code></p></td><td align="left" valign="top"><p><code class="literal">[2,5,8,11,14,17]</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return range(0,10), range(2,18,3)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-reduce">REDUCE</h5>
<div class="paragraph"><p>To run an expression against individual elements of a collection, and store the result of the expression in
 an accumulator, you can use <code>REDUCE</code>. It will go through a collection, run an expression on every element, storing the partial result
 in the accumulator. It works like the <code>fold</code> or <code>reduce</code> method in functional languages such as Lisp and Scala.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>REDUCE( accumulator = initial,  identifier in collection : expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>accumulator:</em> An identifier that will hold the result and the partial results as the collection is iterated
</p>
</li>
<li>
<p>
<em>initial:</em> An expression that runs once to give a starting value to the accumulator
</p>
</li>
<li>
<p>
<em>collection:</em> An expression that returns a collection
</p>
</li>
<li>
<p>
<em>identifier:</em> The closure will have an identifier introduced in it&#8217;s context. Here you decide which identifier to use.
</p>
</li>
<li>
<p>
<em>expression:</em> This expression will run once per value in the collection, and produces the result value.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), b=node(4), c=node(1)
MATCH p=a--&gt;b--&gt;c
RETURN reduce(totalAge = 0, n in nodes(p) : totalAge + n.age)</pre></div>
<div class="paragraph"><p>The age property of all nodes in the path are summed and returned as a single value.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">reduce(totalAge = 0, n in nodes(p) : totalAge + n.age)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">117</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), b=node(4), c=node(1) match p=a--&gt;b--&gt;c return reduce(totalAge = 0, n in nodes(p) : totalAge + n.age)</strong></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_mathematical_functions">Mathematical functions</h4>
<div class="paragraph"><p>These functions all operate on numerical expressions only, and will return
an error if used on any other values.</p></div>
<div class="paragraph"><p>See also <a href="#query-operators-mathematical">[query-operators-mathematical]</a>.</p></div>
<div class="sect4">
<h5 id="functions-abs">ABS</h5>
<div class="paragraph"><p><code>ABS</code> returns the absolute value of a number.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>ABS( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> A numeric expression.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(3), c=node(2)
RETURN a.age, c.age, abs(a.age - c.age)</pre></div>
<div class="paragraph"><p>The absolute value of the age difference is returned.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">a.age</td><td align="left" valign="top">c.age</td><td align="left" valign="top">abs(a.age - c.age)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="3">1 row
</th></tr><tr><th align="left" valign="top" colspan="3">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">38</code></p></td><td align="left" valign="top"><p><code class="literal">41</code></p></td><td align="left" valign="top"><p><code class="literal">3.0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(3), c=node(2) return a.age, c.age, abs(a.age - c.age)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-round">ROUND</h5>
<div class="paragraph"><p><code>ROUND</code> returns the numerical expression, rounded to the nearest integer.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>ROUND( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> A numerical expression.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
RETURN round(3.141592)</pre></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">round(3.141592)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(1) return round(3.141592)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-sqrt">SQRT</h5>
<div class="paragraph"><p><code>SQRT</code> returns the square root of a number.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>SQRT( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> A numerical expression
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START a=node(1)
RETURN sqrt(256)</pre></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">sqrt(256)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">16.0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start a=node(1) return sqrt(256)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-sign">SIGN</h5>
<div class="paragraph"><p><code>SIGN</code> returns the signum of a number&#8201;&#8212;&#8201;zero if the expression is zero, <code>-1</code> for any negative number, and <code>1</code> for any positive number.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>SIGN( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> A numerical expression
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN sign(-17), sign(0.1)</pre></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">sign(-17)</td><td align="left" valign="top">sign(0.1)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">-1.0</code></p></td><td align="left" valign="top"><p><code class="literal">1.0</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return sign(-17), sign(0.1)</strong></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_string_functions">String functions</h4>
<div class="paragraph"><p>These functions all operate on string expressions only, and will return an
error if used on any other values. Except <code>STR()</code>, which converts to
strings.</p></div>
<div class="paragraph"><p>See also <a href="#query-operators-string">[query-operators-string]</a>.</p></div>
<div class="sect4">
<h5 id="functions-str">STR</h5>
<div class="paragraph"><p><code>STR</code> returns a string representation of the expression.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>STR( expression )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>expression:</em> An expression that returns anything
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN str(1)</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">str(1)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"1"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return str(1)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-replace">REPLACE</h5>
<div class="paragraph"><p><code>REPLACE</code> returns a string with the search string replaced by the replace string. It replaces all occurrences.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>REPLACE( original, search, replace )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
<li>
<p>
<em>search:</em> An expression that returns a string to search for
</p>
</li>
<li>
<p>
<em>replace:</em> An expression that returns the string to replace the search string with
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN replace("hello", "l", "w")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">replace("hello", "l", "w")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hewwo"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return replace("hello", "l", "w")</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-substring">SUBSTRING</h5>
<div class="paragraph"><p><code>SUBSTRING</code> returns a substring of the original, with a 0-based index start and length. If length is omitted, it returns a substring from start until the end of the string.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>SUBSTRING( original, start [, length] )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
<li>
<p>
<em>start:</em> An expression that returns a positive number
</p>
</li>
<li>
<p>
<em>length:</em> An expression that returns a positive number
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN substring("hello", 1, 3), substring("hello", 2)</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">substring("hello", 1, 3)</td><td align="left" valign="top">substring("hello", 2)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"ell"</code></p></td><td align="left" valign="top"><p><code class="literal">"llo"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return substring("hello", 1, 3), substring("hello", 2)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-left">LEFT</h5>
<div class="paragraph"><p><code>LEFT</code> returns a string containing the left n characters of the original string.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>LEFT( original, length )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
<li>
<p>
<em>n:</em> An expression that returns a positive number
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN left("hello", 3)</pre></div>
<div class="paragraph"><p>A String.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">left("hello", 3)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hel"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return left("hello", 3)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-right">RIGHT</h5>
<div class="paragraph"><p><code>RIGHT</code> returns a string containing the right n characters of the original string.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>RIGHT( original, length )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
<li>
<p>
<em>n:</em> An expression that returns a positive number
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN right("hello", 3)</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">right("hello", 3)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"llo"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return right("hello", 3)</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-ltrim">LTRIM</h5>
<div class="paragraph"><p><code>LTRIM</code> returns the original string with whitespace removed from the left side.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>LTRIM( original )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN ltrim("   hello")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">ltrim("   hello")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hello"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return ltrim("   hello")</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-rtrim">RTRIM</h5>
<div class="paragraph"><p><code>RTRIM</code> returns the original string with whitespace removed from the right side.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>RTRIM( original )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN rtrim("hello   ")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">rtrim("hello   ")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hello"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return rtrim("hello   ")</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-trim">TRIM</h5>
<div class="paragraph"><p><code>TRIM</code> returns the original string with whitespace removed from both sides.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>TRIM( original )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN trim("   hello   ")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">trim("   hello   ")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hello"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return trim("   hello   ")</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-lower">LOWER</h5>
<div class="paragraph"><p><code>LOWER</code> returns the original string in lowercase.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>LOWER( original )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN lower("HELLO")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">lower("HELLO")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"hello"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return lower("HELLO")</strong></span></p>
</div>
<div class="sect4">
<h5 id="functions-upper">UPPER</h5>
<div class="paragraph"><p><code>UPPER</code> returns the original string in uppercase.</p></div>
<div class="paragraph"><p><strong>Syntax:</strong> <code>UPPER( original )</code></p></div>
<div class="paragraph"><p><strong>Arguments:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<em>original:</em> An expression that returns a string
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Query</div>
<pre class="programlisting brush: cypher">START n=node(1)
RETURN upper("hello")</pre></div>
<div class="paragraph"><p>A string.</p></div>
<div class="openblock">
<div class="title">Result</div>
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">upper("hello")</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"HELLO"</code></p></td></tr></tbody></table></div></div>
 <p class="cypherconsole"><b>Try this query live</b><span class="database">(1) {"age":54,"eyes":"brown","name":"D"}
(2) {"age":41,"array":["one","two","three"],"eyes":"blue","name":"E"}
(3) {"age":38,"eyes":"brown","name":"A"}
(4) {"age":25,"eyes":"blue","name":"B"}
(5) {"age":53,"eyes":"green","name":"C"}
(3)-[:KNOWS]-&gt;(4) {}
(3)-[:KNOWS]-&gt;(5) {}
(4)-[:KNOWS]-&gt;(1) {}
(4)-[:MARRIED]-&gt;(2) {}
(5)-[:KNOWS]-&gt;(1) {}
</span><span class="command"><strong>
 start n=node(1) return upper("hello")</strong></span></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-compatibility">Compatibility</h3>
<div class="paragraph"><p>Cypher is still changing rather rapidly. Parts of the changes are internal&#8201;&#8212;&#8201;we add new pattern matchers, aggregators and other optimizations, which
hopefully makes your queries run faster.</p></div>
<div class="paragraph"><p>Other changes are directly visible to our users&#8201;&#8212;&#8201;the syntax is still
changing. New concepts are being added and old ones changed to fit into new
possibilities. To guard you from having to keep up with our syntax changes,
Cypher allows you to use an older parser, but still gain the speed from new
optimizations.</p></div>
<div class="paragraph"><p>There are two ways you can select which parser to use. You can configure
your database with the configuration parameter <code>cypher_parser_version</code>, and
enter which parser you&#8217;d like to use (1.7, 1.8 and 1.9 are supported
now). Any Cypher query that doesn&#8217;t explicitly say anything else, will get
the parser you have configured.</p></div>
<div class="paragraph"><p>The other way is on a query by query basis. By simply pre-pending your query
with <code>"CYPHER 1.7"</code>, that particular query will be parsed with the 1.7
version of the parser. Example:</p></div>
<div class="listingblock">
<pre class="programlisting brush: cypher">CYPHER 1.7 START n=node(0)
WHERE n.foo = "bar"
RETURN n</pre></div>
</div>
<div class="sect2">
<h3 id="examples-from-sql-to-cypher">From SQL to Cypher</h3>
<div class="paragraph"><p>This guide is for people who understand SQL. You can use that prior
knowledge to quickly get going with Cypher and start exploring Neo4j.</p></div>
<div class="sect3">
<h4 id="_start">Start</h4>
<div class="paragraph"><p>SQL starts with the result you want&#8201;&#8212;&#8201;we <code>SELECT</code> what we want and then
declare how to source it. In Cypher, the <code>START</code> clause is quite a different
concept which specifies starting points in the graph from which the query
will execute.</p></div>
<div class="paragraph"><p>From a SQL point of view, the identifiers in <code>START</code> are like table names
that point to a set of nodes or relationships. The set can be listed
literally, come via parameters, or as I show in the following example, be
defined by an index look-up.</p></div>
<div class="paragraph"><p>So in fact rather than being <code>SELECT</code>-like, the <code>START</code> clause is somewhere
between the <code>FROM</code> and the <code>WHERE</code> clause in SQL.</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT *
FROM "Person"
WHERE name = 'Anakin'</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NAME</td><td align="left" valign="top">ID</td><td align="left" valign="top">AGE</td><td align="left" valign="top">HAIR</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="4">1 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Anakin</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">20</code></p></td><td align="left" valign="top"><p><code class="literal">blonde</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person(name = 'Anakin')
RETURN person</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">person</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">19 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Anakin",id:1,age:20,hair:"blonde"}</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>Cypher allows multiple starting points. This should not be strange from a
SQL perspective&#8201;&#8212;&#8201;every table in the <code>FROM</code> clause is another starting
point.</p></div>
</div>
<div class="sect3">
<h4 id="_match">Match</h4>
<div class="paragraph"><p>Unlike SQL which operates on sets, Cypher predominantly works on
sub-graphs.  The relational equivalent is the current set of tuples being
evaluated during a <code>SELECT</code> query.</p></div>
<div class="paragraph"><p>The shape of the sub-graph is specified in the <code>MATCH</code> clause.  The <code>MATCH</code>
clause is analogous to the <code>JOIN</code> in SQL. A normal a&#8594;b relationship is an
inner join between nodes a and b&#8201;&#8212;&#8201;both sides have to have at least one
match, or nothing is returned.</p></div>
<div class="paragraph"><p>We&#8217;ll start with a simple example, where we find all email addresses that
are connected to the person &#0171;Anakin&#0187;. This is an ordinary one-to-many
relationship.</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT "Email".*
FROM "Person"
JOIN "Email" ON "Person".id = "Email".person_id
WHERE "Person".name = 'Anakin'</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">ADDRESS</td><td align="left" valign="top">COMMENT</td><td align="left" valign="top">PERSON_ID</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="3">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">anakin@example.com</code></p></td><td align="left" valign="top"><p><code class="literal">home</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">anakin@example.org</code></p></td><td align="left" valign="top"><p><code class="literal">work</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person(name = 'Anakin')
MATCH person-[:email]-&gt;email
RETURN email</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">email</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">2 rows
</th></tr><tr><th align="left" valign="top" colspan="1">35 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[7]{address:"anakin@example.com",comment:"home"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[8]{address:"anakin@example.org",comment:"work"}</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>There is no join table here, but if one is necessary the next example will
show how to do that, writing the pattern relationship like so:
<code>-[r:belongs_to]-&gt;</code> will introduce (the equivalent of) join table available
as the variable <code>r</code>.  In reality this is a named relationship in Cypher, so
we&#8217;re saying &#0171;join <code>Person</code> to <code>Group</code> via <code>belongs_to</code>.&#0187; To illustrate
this, consider this image, comparing the SQL model and Neo4j/Cypher.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/RDBMSvsGraph.svg.png" alt="RDBMSvsGraph.svg.png" />
</div>
</div>
<div class="paragraph"><p>And here are example queries:</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT "Group".*, "Person_Group".*
FROM "Person"
JOIN "Person_Group" ON "Person".id = "Person_Group".person_id
JOIN "Group" ON "Person_Group".Group_id="Group".id
WHERE "Person".name = 'Bridget'</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NAME</td><td align="left" valign="top">ID</td><td align="left" valign="top">BELONGS_TO_GROUP_ID</td><td align="left" valign="top">PERSON_ID</td><td align="left" valign="top">GROUP_ID</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="5">1 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Admin</code></p></td><td align="left" valign="top"><p><code class="literal">4</code></p></td><td align="left" valign="top"><p><code class="literal">3</code></p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td><td align="left" valign="top"><p><code class="literal">4</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person(name = 'Bridget')
MATCH person-[r:belongs_to]-&gt;group
RETURN group, r</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">group</td><td align="left" valign="top">r</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">1 row
</th></tr><tr><th align="left" valign="top" colspan="2">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Admin",id:4}</code></p></td><td align="left" valign="top"><p><code class="literal">:belongs_to[0] {}</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>An
<a href="http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html">outer
join</a> is just as easy.  Add a question mark <code>-[?:KNOWS]-&gt;</code> and it&#8217;s an
optional relationship between nodes&#8201;&#8212;&#8201;the outer join of Cypher.</p></div>
<div class="paragraph"><p>Whether it&#8217;s a left outer join, or a right outer join is defined by which
side of the pattern has a starting point.  This example is a left outer
join, because the bound node is on the left side:</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT "Person".name, "Email".address
FROM "Person" LEFT
JOIN "Email" ON "Person".id = "Email".person_id</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NAME</td><td align="left" valign="top">ADDRESS</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">3 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Anakin</code></p></td><td align="left" valign="top"><p><code class="literal">anakin@example.com</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Anakin</code></p></td><td align="left" valign="top"><p><code class="literal">anakin@example.org</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Bridget</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person('name: *')
MATCH person-[?:email]-&gt;email
RETURN person.name, email.address?</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">person.name</td><td align="left" valign="top">email.address?</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">3 rows
</th></tr><tr><th align="left" valign="top" colspan="2">48 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Anakin"</code></p></td><td align="left" valign="top"><p><code class="literal">"anakin@example.com"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Anakin"</code></p></td><td align="left" valign="top"><p><code class="literal">"anakin@example.org"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Bridget"</code></p></td><td align="left" valign="top"><p><code class="literal">&lt;null&gt;</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>Relationships in Neo4j are first class citizens&#8201;&#8212;&#8201;it&#8217;s like the SQL tables
are pre-joined with each other.  So, naturally, Cypher is designed to be
able to handle highly connected data easily.</p></div>
<div class="paragraph"><p>One such domain is tree structures&#8201;&#8212;&#8201;anyone that has tried storing tree
structures in SQL knows that you have to work hard to get around the
limitations of the relational model.  There are even books on the subject.</p></div>
<div class="paragraph"><p>To find all the groups and sub-groups that Bridget belongs to, this query is
enough in Cypher:</p></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person('name: Bridget')
MATCH person-[:belongs_to*]-&gt;group
RETURN person.name, group.name</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">person.name</td><td align="left" valign="top">group.name</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">3 rows
</th></tr><tr><th align="left" valign="top" colspan="2">13 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Bridget"</code></p></td><td align="left" valign="top"><p><code class="literal">"Admin"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Bridget"</code></p></td><td align="left" valign="top"><p><code class="literal">"Technichian"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Bridget"</code></p></td><td align="left" valign="top"><p><code class="literal">"User"</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>The * after the relationship type means that there can be multiple hops
across <code>belongs_to</code> relationships between group and user.  Some SQL dialects
have recursive abilities, that allow the expression of queries like this,
but you may have a hard time wrapping your head around those.  Expressing
something like this in SQL is hugely impractical if not practically
impossible.</p></div>
</div>
<div class="sect3">
<h4 id="_where">Where</h4>
<div class="paragraph"><p>This is the easiest thing to understand&#8201;&#8212;&#8201;it&#8217;s the same animal in both
languages.  It filters out result sets/subgraphs.  Not all predicates have
an equivalent in the other language, but the concept is the same.</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT *
FROM "Person"
WHERE "Person".age &gt; 35 AND "Person".hair = 'blonde'</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NAME</td><td align="left" valign="top">ID</td><td align="left" valign="top">AGE</td><td align="left" valign="top">HAIR</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="4">1 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Bridget</code></p></td><td align="left" valign="top"><p><code class="literal">2</code></p></td><td align="left" valign="top"><p><code class="literal">40</code></p></td><td align="left" valign="top"><p><code class="literal">blonde</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person('name: *')
WHERE person.age &gt; 35 AND person.hair = 'blonde'
RETURN person</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">person</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="1">1 row
</th></tr><tr><th align="left" valign="top" colspan="1">1 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Bridget",id:2,age:40,hair:"blonde"}</code></p></td></tr></tbody></table></div></div>
</div>
<div class="sect3">
<h4 id="_return">Return</h4>
<div class="paragraph"><p>This is SQL&#8217;s <code>SELECT</code>.  We just put it in the end because it felt better to
have it there&#8201;&#8212;&#8201;you do a lot of matching and filtering, and finally, you
return something.</p></div>
<div class="paragraph"><p>Aggregate queries work just like they do in SQL, apart from the fact that
there is no explicit <code>GROUP BY</code> clause.  Everything in the return clause
that is not an aggregate function will be used as the grouping columns.</p></div>
<div class="listingblock">
<div class="title">SQL Query</div>
<pre class="programlisting brush: sql">SELECT "Person".name, count(*)
FROM "Person"
GROUP BY "Person".name
ORDER BY "Person".name</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">NAME</td><td align="left" valign="top">C2</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Anakin</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Bridget</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr></tbody></table></div></div>
<div class="listingblock">
<div class="title">Cypher Query</div>
<pre class="programlisting brush: cypher">START person=node:Person('name: *')
RETURN person.name, count(*)
ORDER BY person.name</pre></div>
<div class="openblock">
<div class="content"><table class="queryresult" border="1" cellspacing="0" cellpadding="0"><thead><tr><td align="left" valign="top">person.name</td><td align="left" valign="top">count(*)</td></tr></thead><tfoot><tr><th align="left" valign="top" colspan="2">2 rows
</th></tr><tr><th align="left" valign="top" colspan="2">0 ms</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Anakin"</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Bridget"</code></p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td></tr></tbody></table></div></div>
<div class="paragraph"><p>Order by is the same in both languages&#8201;&#8212;&#8201;<code>ORDER BY</code> expression
<code>ASC</code>/<code>DESC</code>.  Nothing weird here.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="questions">Appendice A: Questions &amp; Réponses</h2>
<div class="sectionbody">
<div class="qlist qanda"><ol>
<li>
<p><em>
Quel est le nombre maximum de noeuds supportés? Quel est le nombre maximum de relations supportées par noeud?
</em></p>
<p>
        At the moment it is 34.4 billion nodes, 34.4 billion relationships, and at a
        minimum 68.7 billion properties (maximum is 274 billion, depending on the
        property types), in total.
</p>
</li>
<li>
<p><em>
Quel est le plus grand graphe connecté supporté (ex: chaque noeud est connecté à tous les autres noeuds)?
</em></p>
<p>
        Les limites théoriques sont dépendants des chiffres ci-dessus: Basiquement
        cela représente un graphe complet de 262144 noeuds et 34359607296
        relations. Cependant nous n&#8217;avons encore jamais rencontré ce genre de
        situation.
</p>
</li>
<li>
<p><em>
Est-ce que les opérations de lecture/écriture sont dépendantes du nombre de noeuds/relations dans la BDD?
</em></p>
<p>
        Cette question peut signifier beaucoup de choses différentes. La performance
        d&#8217;une simple opération de lecture/écriture ne dépend pas de la tailler de la
        BDD. Le fait que le graphe contienne 10 noeuds ou 10 millions de noeuds n&#8217;a
        aucune importance. &#8201;&#8212;&#8201;Il y a cependant un autre facteur ici, si votre
        graphe prend beaucoup de place sur le disque, il se peut qu&#8217;il ne sache pas
        être introduit dans le cache de la NVRAM. Dans ce cas, vous pourriez
        rencontrer des opérations sur le disque plus fréquentes. La plupart des
        clients n&#8217;ont pas de graphes de cette taille, mais certains en ont. Si vous
        devriez atteindre cette taille, nous disposons d&#8217;approches consistant à
        l'élargissement de la BDD sur plusieurs machines afin d&#8217;atténuer l&#8217;impact de
        performance en agrandissant la surface de chache entre les machines.
</p>
</li>
<li>
<p><em>
Combien d&#8217;opérations de lecture/écriture concurrentes sont supportées?
</em></p>
<p>
        Il n&#8217;y a pas de limite en nombre de requêtes concurrentes. Le nombre de
        requêtes qui peuvent être traitées par seconde dépend principalement sur le
        type d&#8217;opération exécutée (opération d'écriture lourde, lecture simple,
        traversée complexe, etc.) et du matériel physique utilisé. Une estimation de
        1000 hops par milliseconde pour une simple traversée de graphe de façon
        basique. Après une discussion sur le type d&#8217;usage spécifique, nous serions
        en mesure de donner une meilleure estimation de la performance qu&#8217;une
        requête demanderait.
</p>
</li>
<li>
<p><em>
Comment est-ce que les données sont maintenues en cohérence dans un environnement de grappes de serveurs (cluster)?
</em></p>
<p>
        Réplication maître-esclave. Les esclaves récupèrent les changements sur le
        maître. L&#8217;intervalle de récupération peut-être configurée pour chaque
        esclave, de dixièmes de secondes en minutes, ensuite l'écriture est durable
        sur l&#8217;esclave et le maître. Les autres esclaves procèdent ensuite à la
        normale.
</p>
</li>
<li>
<p><em>
Comment est le temps de latence pendant la mise à jour de tous les serveurs quand il y a une mise à jour sur l&#8217;un de ceux-ci?
</em></p>
<p>
        L&#8217;intervalle des temps de récupération peuvent être configurés par esclave,
        de dixièmes de secondes en minutes, selon le besoin. Quand on écrit sur un
        esclave, celui-ci est immédiatement synchronisé avec le maître avant que
        l&#8217;opération d'écriture soit exécutée sur l&#8217;esclave et le maître. En général
        la charge des opérations de lecture/écriture n&#8217;affecte pas les esclaves en
        synchronisation. Une lourde opération d'écriture occasionera cependant une
        grosse pression sur le système de fichiers du maître, ce qui sera également
        requis par les esclaves pour la lecture des changements.  Cependant cela
        n&#8217;est pas encore apparu être un problème notable en pratique.
</p>
</li>
<li>
<p><em>
Est-ce que l&#8217;augmentation du temps de latence est proportionnelle au nombres de serveurs dans la grappe (cluster)?
</em></p>
<p>
        En évoluant vers des dizaines d&#8217;esclaves sur la grappe, nous anticipons le
        fait que le nombre de requêtes de récupération réduira la performance du
        serveur maître. Seulement les opérations d'écriture sur la grappe seront
        affectées, les opérations de lecture continueront à s'échelonner
        linéairement.
</p>
</li>
<li>
<p><em>
Est-ce que l&#8217;expansion à chaud est supportée? En d&#8217;autres termes doit-on couper tous les serveurs et la base de données afin d&#8217;ajouter un nouveau serveur sur la grappe?
</em></p>
<p>
        De nouveaux esclaves peuvent être ajoutés sans devoir arrêter et démarrer
        toute la grappe. Notre protocole de haute-disponibilité ajoutera un nouvel
        esclave à jour. Les esclaves peuvent également être retirés à chaud
        simplement en les arrêtant.
</p>
</li>
<li>
<p><em>
Combien de temps est nécessaire pour qu&#8217;un nouvel esclave soit synchronisé?
</em></p>
<p>
        Nous vous recommandons de munir votre nouvel esclave d&#8217;une version snapshot
        récente de la base de données avant de le mettre en ligne. Ceci est
        généralement réalisé pendant les opérations de sauvegarde. L&#8217;esclave ne
        devra alors synchroniser que les mises à jour les plus récentes, qui seront
        réalisées normalement en quelques secondes.
</p>
</li>
<li>
<p><em>
Combien de temps nécessite un redémarrage?
</em></p>
<p>
        Si par redémarrage, vous entendez arrêter le cluster et le redémarrer, cela
        dépend réellement de la vitesse à laquelle vous savez taper au clavier.
        Donc cela devrait rester en dessous des 10 secondes. Les caches Neo4j ne
        seront cependant pas démarrés à chaud mais le cache du système de fichiers
        gardera lui ses données.
</p>
</li>
<li>
<p><em>
Existe-t-il des solutions de sauvegarde/restauration?
</em></p>
<p>
        Neo4j Enterprise Edition fournit une fonctionnalité de sauvegarde en
        ligne. Des sauvegardes complètes ou incrémentielles peuvent être réalisées
        en production.
</p>
</li>
<li>
<p><em>
Est-ce qu&#8217;un grappage cross-continental est supporté. En gros, est-ce que des serveurs en grappe localisés dans des continents différents créent une possibilité que les communications inter-continentales soient plus lentes que les intra-continentales?
</em></p>
<p>
        Nous avons des clients qui ont testé des déploiements multi-régions en
        AWS. Les temps de latence inter-continentaux seront affectés, sur les
        prototcoles de gestion et synchronisation des clusters. De larges latences
        dans le cluster peuvent déclencher des ré-élections du mâitre fréquentes, ce
        qui aura pour effet de ralentir le cluster. Le support de cette
        fonctionnalité sera amélioré dans le temps.
</p>
</li>
<li>
<p><em>
Existe-t-il des politiques/conseils d&#8217;utilisation pour ce type de configuration?
</em></p>
<p>
        Nous devrions avoir une discussion détaillé à propos des spécificités et
        besoins relatifs à ce type de déploiement.
</p>
</li>
<li>
<p><em>
Est-ce que l'écriture dans la BDD est sécurisée par processus? Ou est-ce à l&#8217;application de fournir une protection d'écriture dans les mêmes noeuds/relations?
</em></p>
<p>
        Aussi bien en instance simple qu&#8217;en mode haute-disponibilité, la base de
        données fournit une protection en vérouillant les noeuds et relations contre
        l'écriture.
</p>
</li>
<li>
<p><em>
Quelle est la meilleure stratégie afin de récupérer les écritures en mode haute-disponibilité?
</em></p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Sessions permanentes
</p>
</li>
<li>
<p>
Renvoyer les données dans la réponse, enlever le besoin de récupérer les
           écritures dans une requête séparée
</p>
</li>
<li>
<p>
Forcer une récupération de mises à jour depuis le maître quand nécessaire
</p>
</li>
</ol></div>
</li>
<li>
<p><em>
Quelle est la meilleure stratégie pour les opérations de get-or-create?
</em></p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Processus unique.
</p>
</li>
<li>
<p>
Si il n&#8217;existe pas, vérouillage péssimiste sur un noeud (ou un jeu de
           noeuds).
</p>
</li>
<li>
<p>
Si il n&#8217;existe pas, création optimiste, et double contrôle après (cette
           explication sera étendue).
</p>
</li>
</ol></div>
</li>
<li>
<p><em>
Comment fonctionne le vérouillage?
</em></p>
<p>
        Vérouillage péssimiste.  Les vérous ne sont jamais requis pour les
        lectures. Les écritures ne bloqueront pas les lectures. Il est impossible de
        réaliser des bloquages d&#8217;opérations de lecture sans utiliser des moyens de
        vérouillage explicite.  Les vérous de lecture se répercutent les les
        écritures. Un vérou de lecture signifie une vue consistente pour tous les
        détenteurs.  Les vérous d'écriture sont engendrés automatiquement quand un
        noeud/relations est modifié/créé, ou par des moyens de vérous
        explicites. <strong>*</strong>
</p>
</li>
<li>
<p><em>
Qu&#8217;en est-il du stockage de taille?
</em></p>
<p>
        Neo4j n&#8217;est pour l&#8217;instant pas prévu pour stocker des BLOBs/CLOBs.  Les
        noeuds, relations et propriétés ne sont pas co-localisées sur le
        disque. Cela sera peut-être introduit dans le futur.
</p>
</li>
<li>
<p><em>
Qu&#8217;en est-il de l&#8217;indexation?
</em></p>
<p>
        Neo4j supporte les indices de propriétés composés.  Présente des indices du
        graphe aux fournisseurs d&#8217;index.  Le moteur Lucene gère la pagination de
        l&#8217;index en interne et requière sa propre mémoire.  Neo4j supporte
        actuellement un indexeur automatique et plusieurs indexs individuels
        (recherche effectée via l&#8217;API);
</p>
</li>
<li>
<p><em>
Comment est-ce que je questionne la base de données?
</em></p>
<p>
        Core API, API de Traversées, API ReST, Cypher, Gremlin.
</p>
</li>
<li>
<p><em>
Comment utiliser la journalisation?
</em></p>
<p>
        En se basant sur les deltas de modifications d'écriture entre le maître et
        les esclaves sur une grappe de serveurs.
</p>
</li>
<li>
<p><em>
Comment est-ce que j&#8217;optimise Neo4j pour la performance?
</em></p>
<p>
        Utilisation de fichiers de mémoire en accès linéaire (memory-mapped)  Les
        stratégies de mise en cache de Neo4j doivent être expliquées:
</p>
<div class="ulist"><ul>
<li>
<p>
Soft-ref cache: Les soft references sont effacées quand le GC pense que
          c&#8217;est nécessaire. A utiliser si la charge de l&#8217;application n&#8217;est pas très
          grande et qu&#8217;on a besoin d&#8217;un cache soignant la mémoire.
</p>
</li>
<li>
<p>
Weak-ref cache: Le GC efface les weak references quand il en trouve. A
          utiliser si l&#8217;application est soumise à une forte charge avec un grand
          nombre de lectures et de traversées.
</p>
</li>
<li>
<p>
Strong-ref cache: Tous les noeuds et relations sont mises dans le cache
          mémoire.
        JVM a besoin d&#8217;une pause après une forte charge, par exemple 1/2 minutes
        d&#8217;intervalle.  Des heap sizes larges sont bons, sinon 12G et plus ne sont
        pas pratiques avec le GC.  Une augmentation de performance de 100x avec de
        larges fichiers memory-mapped de cache et 1000x avec les heap sizes Java en
        comparaison avec les opérations de lecture/écriture sur le disque.
</p>
</li>
</ul></div>
</li>
<li>
<p><em>
Transactions ACID entre le maître et les esclaves?
</em></p>
<p>
        Synchronisé entre les opérations initiées depuis un esclave vers le maître,
        éventuellement de maître vers esclave.  Transactions concurentes initiées
        depuis plusieurs esclaves supportées avec détection deadlock.  Complètement
        consistent d&#8217;un point de vue intégrité des données, éventuellement
        consistent d&#8217;un point de vue synchronisation.
</p>
</li>
<li>
<p><em>
Qu&#8217;en est-il du serveur standalone?
</em></p>
<p>
        L&#8217;API ReST est complètement stateless, mais peut exécuter des opérations en
        masse pour de grandes transactions.  Pile de processus et processus par
        socket: POur le mode serveur standalone &amp; noeuds HD, Neo4j utilise Jetty
        pour la connection de la pile (par ex: 25/noeud en cluster HD)
</p>
</li>
<li>
<p><em>
Comment est-utilisé un Load-Balancer avec le mode HD?
</em></p>
<p>
        Typiquement une petite extension serveur peut être écrite afin de retourner
        200 ou 404 en fonction de la machine qui est maître et de celle qui est
        esclave.  Cette extension peut ensuite être contactée par le load balancer
        afin de savoir quelle machine est maître et laquelle est esclave.  En
        écrivant exclusivement sur les esclaves, on s&#8217;assure d&#8217;avoir des opérations
        d'écriture à au moins deux endroits.
</p>
</li>
<li>
<p><em>
Quel système de monitoring est fourni avec Neo4j?
</em></p>
<p>
        Neo4j n&#8217;a pour l&#8217;instant pas de systèmes de tracage ou de plans explicites.
        JMX est l&#8217;interface principale pour les statistiques et le monitoring.  Les
        dumps de processus peuvent être utilisés pour débugger un système non
        fonctionnel.
</p>
</li>
<li>
<p><em>
Comment importer les données dans Neo4j?
</em></p>
<p>
        The Neo4j batch inserter can be used to fill an initial database with data.
        After batch insertion, the store can be used in an embedded or HA
        environment.  Future data load/refresh should go directly to Production
        server SQL Importer (built on top of Batch Inserter) is not officially
        supported.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Dernière mise à jour 2013-03-19 05:11:32 GMT
</div>
</div>
</body>
</html>
